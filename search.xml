<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RxJava系列 - (1)初步认识</title>
      <link href="/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(1)%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
      <url>/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(1)%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><ul><li><p><strong>RxJava的观察者模式</strong></p><blockquote><p>RxJava有四个基本概念：<strong>Observable</strong> (可观察者，即被观察者)、<strong>Observer</strong> (观察者)、<strong>subscribe</strong> (订阅)、事件。<br><strong>Observable</strong> 和 <strong>Observer</strong> 通过 <strong>subscribe()</strong>方法实现订阅，从而 <strong>Observable</strong> 可以在需要的时候发出事件了通知<strong>Observer</strong>。</p></blockquote></li><li><p><strong>回调事件 : onCompleted()、onError()</strong><br>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 <strong>onNext()</strong> （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：<strong>onCompleted()</strong> 和 <strong>onError()</strong>。</p><blockquote><p><strong>onCompleted() : </strong>:事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 <strong>onNext()</strong> 发出时，需要触发 <strong>onCompleted()</strong> 方法作为标志。</p><p><strong>onError() : </strong> 事件队列异常。在事件处理过程中出异常时，<strong>onError()</strong> 会被触发，同时队列自动终止，不允许再有事件发出。</p><p>在一个正确运行的事件序列中, <strong>onCompleted()</strong> 和 <strong>onError()</strong> 有且只有一个，并且是事件序列中的最后一个。需要注意的是，<strong>onCompleted()</strong> 和 <strong>onError()</strong> 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p></blockquote></li></ul><hr><a id="more"></a><h4 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2.基本实现"></a>2.基本实现</h4><p>基于以上的概念， RxJava 的基本实现主要有三点：</p><ul><li><p><strong>创建Observer</strong><br>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>  除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Observable</strong><br><strong>Observable</strong> 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 <strong>create()</strong> 方法来创建一个 <strong>Observable</strong> ，并为它定义事件触发规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            e.onNext(<span class="string">""</span>);</span><br><span class="line">            e.onNext(<span class="string">""</span>);</span><br><span class="line">            e.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>除了最基本的创建事件的方法<strong>create()</strong>之外，RxJava还提供了一些快捷的方法来创建事件队列，例如：</p><ol><li><p><strong>just(T…) </strong>将传入的参数一次发送出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将会依次调用：onNext("A");onNext("B");onNext("C");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Observable&lt;String&gt; observable1 = Observable.just(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>fromArray(T) / Observable.fromIterable()</strong> 将传入的数组或 Iterable 拆分成具体对象后，依次发送出去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 将会依次调用：onNext(&quot;A&quot;);onNext(&quot;B&quot;);onNext(&quot;C&quot;);</span><br><span class="line"> */</span><br><span class="line">private String[] s = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;;</span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.fromArray(s);</span><br><span class="line"></span><br><span class="line">//list集合中迭代处理</span><br><span class="line">List&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">Observable&lt;String&gt; observable3 = Observable.fromIterable(list);</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>Subscribe订阅</strong><br>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-简单易懂的实现方式"><a href="#3-简单易懂的实现方式" class="headerlink" title="3.简单易懂的实现方式"></a>3.简单易懂的实现方式</h4><p>上面的概念太难理解了，这里我们给个生动的比喻，然后再来一个通俗易懂的示例加深理解。</p><h5 id="1-图示与代码"><a href="#1-图示与代码" class="headerlink" title="1. 图示与代码"></a>1. 图示与代码</h5><ul><li><p><strong>图示  ： 借用水管的概念来替代观察者和被观察者，以及事件的流向来阐述RxJava的原理</strong></p><blockquote><p><img src="https://i.loli.net/2019/10/30/PDmV4urInpeTUci.png" alt="水管事件流向图"></p><p>我们依据上图的水管来描述一下事件：</p><ol><li>上面的水管为事件产生的水管，我们称之为<strong>上游</strong>，下面的水管为事件接收的水管，我们称之为<strong>下游</strong></li><li>上游、下游通过一定的方式连接，上游按照<strong>1、2、3的顺序</strong>发送事件，下游按照<strong>1、2、3的顺序</strong>接收事件(和官网的相反)</li><li>上游、下游分别对应RxJava中的<strong>Observable</strong>和<strong>Observer</strong>,他们之间的连接就对应着<strong>subscribe()</strong></li></ol></blockquote></li><li><p><strong>代码 ： 表示RxJava的关系如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个水管上游</span></span><br><span class="line">    Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            e.onNext(<span class="string">"第一个事件"</span>);</span><br><span class="line">            e.onNext(<span class="string">"第二个事件"</span>);</span><br><span class="line">            e.onNext(<span class="string">"第三个事件"</span>);</span><br><span class="line">            <span class="comment">//事件结束</span></span><br><span class="line">            e.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2. 创建一个下游</span></span><br><span class="line">    Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"onSubscribe Disposable : "</span>+d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull String s)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"onNext  s :"</span>+s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"onError"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"onComplete --- 事件结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3. 建立连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startRx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//只有上游和下游建立了连接之后才会开始发送事件，即调用了subscribe()方法</span></span><br><span class="line">        observable.subscribe(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 运行结果</span></span><br><span class="line">D/RxJava: onSubscribe Disposable : <span class="keyword">null</span></span><br><span class="line">D/RxJava: onNext  s :第一个事件</span><br><span class="line">D/RxJava: onNext  s :第二个事件</span><br><span class="line">D/RxJava: onNext  s :第三个事件</span><br><span class="line">D/RxJava: onComplete --- 事件结束</span><br></pre></td></tr></table></figure></li></ul><p>是不是觉得和其他的调用方式没什么区别呢？那我们来看下更灵活的调用方式。</p><hr><h5 id="2-链式调度"><a href="#2-链式调度" class="headerlink" title="2. 链式调度"></a>2. 链式调度</h5><ul><li><strong>RxJava的链式调度</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="string">"链式调度1"</span>);</span><br><span class="line">                e.onNext(<span class="string">"链式调度2"</span>);</span><br><span class="line">                e.onNext(<span class="string">"链式调度3"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onSubscribe Disposable : "</span>+d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onNext  s : "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onError"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">D/RxJava: onSubscribe Disposable : <span class="keyword">null</span></span><br><span class="line">D/RxJava: onNext  s : 链式调度<span class="number">1</span></span><br><span class="line">D/RxJava: onNext  s : 链式调度<span class="number">2</span></span><br><span class="line">D/RxJava: onNext  s : 链式调度<span class="number">3</span></span><br><span class="line">D/RxJava: onComplete</span><br></pre></td></tr></table></figure></li></ul><p>从链式调度来看简洁明了，比较符合现在的编码习惯，我们来看下这一连串的代码中比较陌生的部分：<br><strong><code>ObservableEmitter</code></strong> 和 <strong><code>Disposable</code></strong>.</p><h5 id="3-陌生对象"><a href="#3-陌生对象" class="headerlink" title="3.陌生对象"></a>3.陌生对象</h5><ul><li><p><strong>(1) ObservableEmitter</strong></p><blockquote><p>Emitter是发射的意思，所以来看这个应该就是指的：<strong>事件发出</strong>，他有三种不同的事件类型：<strong>onNext(T value)、onComplete()、onError(Throwable error)</strong>，分别指的就是next事件、complete事件和error事件。</p><p>这些事件并不是毫无规则、随意发射的，需要满足一定的规则：</p><ul><li>上游可以发送无限个onNext，下游可以接收无限个onNext。</li><li>当上游发送了一个onComplete事件后，上游处于onComplete之后的事件还会继续发送；而下游在接收到onComplete事件之后，将不再继续接收其他事件。</li><li>当上游发送了一个onError事件后，上游处于onError之后的事件还会继续发送；而下游在接收到onError事件之后，将不再继续接收其他事件。</li><li>上游可以不发送onComplete 或 onError 事件</li><li><strong>重点：onComplete事件和onError事件必须唯一且互斥，</strong>即不能发送多个onComplete事件，也不能发送多个onError事件，也不能先发一个onComplete事件，再发送一个onError事件，反之亦然。</li></ul><blockquote><p>注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, 并不一定会导致程序崩溃. 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃.</p></blockquote></blockquote></li><li><p><strong>事件发送规则示意图</strong> </p><p><strong>onNext事件:</strong><br><img src="https://i.loli.net/2019/10/30/zctx2MJFVdAYXvB.png" alt="onNext事件"></p><p><strong>onComplete事件:</strong><br><img src="https://i.loli.net/2019/10/30/Cti3mXU572hcSOK.png" alt="onComplete事件"> </p><p><strong>onError事件:</strong><br><img src="https://i.loli.net/2019/10/30/3z4BvWkJE5YhSdZ.png" alt="onError事件"></p></li><li><p><strong>(2) Disposable</strong></p><blockquote><p>Disposable意思为一次性，放入到RxJava中来理解这个的话，可以是当调用了<strong>dispose()</strong>方法之后，上游与下游之间的连接就中断了，从而导致下游收不到事件，<strong>但是并不会阻止上游继续发送剩余的事件</strong>。</p></blockquote><p>  下面我们就来看下上游持续发送事件，下游在收到<strong>1</strong>的标识之后中断水管间的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="string">"链式调度1"</span>);</span><br><span class="line">                e.onNext(<span class="string">"链式调度2"</span>);</span><br><span class="line">                Log.d(TAG,<span class="string">"subscribe  下面要终止事件了。。。"</span>);</span><br><span class="line">                e.onNext(<span class="string">"1"</span>);</span><br><span class="line">                Log.d(TAG,<span class="string">"subscribe  上面已经终止事件，但是我还要继续。。。"</span>);</span><br><span class="line">                e.onNext(<span class="string">"链式调度3"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Disposable disposable;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onSubscribe Disposable : "</span>+d);</span><br><span class="line">                disposable = d;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onNext  s : "</span>+s);</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">"1"</span>))&#123;</span><br><span class="line">                    disposable.dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                Log.d(TAG,<span class="string">"onNext  disposable.isDisposed : "</span>+disposable.isDisposed());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onError"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">D/RxJava: onSubscribe Disposable : <span class="keyword">null</span></span><br><span class="line">D/RxJava: onNext  s : 链式调度<span class="number">1</span></span><br><span class="line">D/RxJava: onNext  disposable.isDisposed : <span class="keyword">false</span></span><br><span class="line">D/RxJava: onNext  s : 链式调度<span class="number">2</span></span><br><span class="line">D/RxJava: onNext  disposable.isDisposed : <span class="keyword">false</span></span><br><span class="line">D/RxJava: subscribe  下面要终止事件了。。。</span><br><span class="line">D/RxJava: onNext  s : <span class="number">1</span></span><br><span class="line">D/RxJava: onNext  disposable.isDisposed : <span class="keyword">true</span></span><br><span class="line">D/RxJava: subscribe  上面已经终止事件，但是我还要继续。。。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>从上面的日志我们可以看到，在收到标识为<strong>1</strong>后，我们中断了水管，isDisposed 这个标志的返回值编变成了：<strong>disposable.isDisposed : true</strong>，表明事件已经被中断，下游将不再接收任何事件。</p><p>但是我们可以看到这句：<strong>上面已经终止事件，但是我还要继续。。。</strong>，在水管中断了之后，上游还是继续发送了剩余的事件，从而可以看出：<strong>调用 disposable.dispose()方法后，上游会继续发送完剩余的事件，但是下游并不会接收中断后的事件。</strong></p><p>这个以水管来说就是：一根正在流水的管子，从中间堵住，上面的水还是会继续的向下流，只不过是堵起来了；但是下游不会有水流下来了。</p></blockquote><h5 id="4-subscribe的重载方法"><a href="#4-subscribe的重载方法" class="headerlink" title="4.subscribe的重载方法"></a>4.subscribe的重载方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError)</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) 带有<code>Observer</code>参数的<code>subscribe()</code>使用方法时可以参考上面的处理；</li><li>(2) 不带任何参数的<code>subscribe()</code>方法，表示我不关心上游的任何事件，不管是数据还是什么都不会去理会；</li><li>(3) 带有一个参数的<code>subscribe()</code>方法，表示下游只关心上游的onNext事件，其他事件就当做没看见，随便你们在处理；</li></ul><hr><h4 id="4-重点推荐：RxJava2-0的系列文章"><a href="#4-重点推荐：RxJava2-0的系列文章" class="headerlink" title="4.重点推荐：RxJava2.0的系列文章"></a>4.重点推荐：RxJava2.0的系列文章</h4><p>这是一个关于RxJava2.0的系列教程，很有学习的价值，我的例子也是参考而来，重点推荐大家看下。<br><a href="http://www.jianshu.com/p/464fa025229e" target="_blank" rel="noopener">给初学者的RxJava2.0教程</a></p>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxJava系列 - (2)线程控制</title>
      <link href="/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(2)%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(2)%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><p>RxJava还提供了强大的线程控制模型，我们可以根据不同的需求指定相应的线程进行控制。</p><h4 id="1-统一线程执行任务"><a href="#1-统一线程执行任务" class="headerlink" title="1.统一线程执行任务"></a>1.统一线程执行任务</h4><p><img src="https://i.loli.net/2019/10/30/Olc23vMm19T7Uwy.png" alt="水管模式1"></p><p>我们还是以水管作为我们的模型，一般在未指定线程的情况下，上游和下游都是处在同一个线程中(Android中默认为主线程)，即上游在哪个线程中发送事件，下游就在哪个线程中接收事件。</p><ul><li><strong>Android默认主线程</strong><br>我们举个例子说明上面的默认线程：主线程。假设在<code>onCreate</code>中有如下操作：上游创建Observable，下游接收事件，分别通过日志查看上游、下游所处的线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上游、下游事件</span></span><br><span class="line"> Observable&lt;String&gt; o1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="string">"Thread Test"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"subscribe-onNext所在线程 ："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"consumer-accept接收数据 : "</span> +o+<span class="string">";  所在thread : "</span>+ Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">o1.subscribe(consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">D/RxJava: consumer-accept接收数据 : Thread Test;  所在thread : main<span class="comment">//上游</span></span><br><span class="line">D/RxJava: subscribe-onNext所在线程 ：main  <span class="comment">//下游</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看到上游<code>Observable</code>在主线程中发送了事件，下游<code>Consumer</code>同样在主线程接收事件，从水管模型来说就是上游、下游是在同一根水管中流动着。</p><hr><a id="more"></a><h4 id="2-切换线程执行任务"><a href="#2-切换线程执行任务" class="headerlink" title="2.切换线程执行任务"></a>2.切换线程执行任务</h4><p>显然上面的模式不太符合我们实际的需求，比如：我们需要在子线程中进行耗时操作，然后回到主线程中更新UI，使用水管来描述就是如下图：<br><img src="https://i.loli.net/2019/10/30/VXDs6rZCQuUS4tl.png" alt="水管模式2"></p><p>图中我们用<code>黄色表示子线程，蓝色表示主线程</code>，即上游在子线程发送事件，下游在主线程接收事件，线程的控制就交给RxJava来进行调度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上游、下游事件，事件的创建方式不变</span></span><br><span class="line"> Observable&lt;String&gt; o1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="string">"Thread Test"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"subscribe-onNext所在线程 ："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"consumer-accept接收数据 : "</span> +o+<span class="string">";  所在thread : "</span>+ Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//事件调用</span></span><br><span class="line"><span class="comment">//subscribeOn一般指定上游,observeOn一般指定下游</span></span><br><span class="line">o1.subscribeOn(Schedulers.newThread())<span class="comment">//子线程</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())<span class="comment">//主线程</span></span><br><span class="line">        .subscribe(consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">RxJava: consumer-accept接收数据 : Thread Test;  所在thread : main  <span class="comment">//主线程接收事件</span></span><br><span class="line">D/RxJava: subscribe-onNext所在线程 ：RxNewThreadScheduler-<span class="number">49</span>  <span class="comment">//子线程发送事件</span></span><br></pre></td></tr></table></figure></p><p>事件的创建方式没有改变，只是在调用事件时增加了两句代码：<br><code>.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread())</code><br> 通过日志就可看到，上游发送事件是在名为：<code>RxNewThreadScheduler-49</code>的线程中，而下游接收事件是在<code>main</code>即主线程中。</p><p>一般来说可以这么理解：<code>subscribeOn()</code>方法用于指定上游发送事件的线程，<code>observeOn()</code>方法用于指定下游接收事件的线程。</p><p>自然我们就会产生疑问：<strong>多次调用线程切换会是什么结果呢？是遵循第一次的还是遵循最后调用的呢?</strong></p><ul><li>多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略.</li><li>多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次.</li></ul><p>线程的创建不变，我们看下调用时多次切换线程的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">发送事件时先指定子线程，然后切换到io线程；接收事件时先指定主线程，然后切换到子线程，再切换到熊线程。</span><br><span class="line"></span><br><span class="line"><span class="comment">//上游多次指定线程只有第一次会生效</span></span><br><span class="line">o1.subscribeOn(Schedulers.newThread())</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        <span class="comment">//下游多次指定线程，每次都会生效</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .observeOn(Schedulers.newThread())</span><br><span class="line">        .observeOn(Schedulers.io())</span><br><span class="line">        .subscribe(consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">D/RxJava: subscribe-onNext所在线程 ：RxNewThreadScheduler-<span class="number">1</span></span><br><span class="line">D/RxJava: consumer-accept接收数据 : Thread Test;  所在thread : RxCachedThreadScheduler-<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>从日志来看，发送事件是在<code>RxNewThreadScheduler-1线程</code>，接收事件是在<code>RxCachedThreadScheduler-2线程</code>。其中<strong><code>CachedThread表示的是IO线程池中的一个</code></strong>，我们上游、下游最后切换到的都是<code>Schedulers.io()</code>，但是只有下游处于IO线程中，所以验证了我们上面的结论：<strong>多次切换线程，上游subscribeOn()只有第一次有效，下游observeOn()每次都会生效，切换线程。</strong></p><p>除了上面的形式之外,我们还可以在调用<code>doOnNext()</code>之前指定线程，达到切换线程的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上游多次指定线程只有第一次会生效</span></span><br><span class="line">o1.subscribeOn(Schedulers.newThread())</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        <span class="comment">//下游多次指定线程，每次都会生效</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .observeOn(Schedulers.io())</span><br><span class="line">        .doOnNext(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//IO线程</span></span><br><span class="line">            Log.d(TAG, <span class="string">"IOThread : doOnNext-accept :"</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .doOnNext(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//主线程</span></span><br><span class="line">            Log.d(TAG, <span class="string">"MainThread : doOnNext-accept :"</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .observeOn(Schedulers.newThread())</span><br><span class="line">        <span class="comment">//子线程</span></span><br><span class="line">        .subscribe(consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">D/RxJava: subscribe-onNext所在线程 ：RxNewThreadScheduler-<span class="number">1</span></span><br><span class="line">D/RxJava: IOThread : doOnNext-accept :RxCachedThreadScheduler-<span class="number">2</span></span><br><span class="line">D/RxJava: MainThread : doOnNext-accept :main</span><br><span class="line">D/RxJava: consumer-accept接收数据 : Thread Test;  所在thread : RxNewThreadScheduler-<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以看到在执行<code>doOnNext()</code>方法之前分别指定了IO线程和AndroidMain线程，日志结果也明确的反应出了两个方法在不同线程中执行的结果。</p><hr><h4 id="3-RxJava提供的多种线程"><a href="#3-RxJava提供的多种线程" class="headerlink" title="3.RxJava提供的多种线程"></a>3.RxJava提供的多种线程</h4><p>在RxJava中, 已经内置了很多线程选项供我们选择, 例如有：</p><ul><li>Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作</li><li>Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作</li><li>Schedulers.newThread() 代表一个常规的新线程</li><li>AndroidSchedulers.mainThread() 代表Android的主线程</li></ul><p>这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高.</p><hr><h4 id="4-简单实例：获取天气"><a href="#4-简单实例：获取天气" class="headerlink" title="4.简单实例：获取天气"></a>4.简单实例：获取天气</h4><p>我们以获取天气作为实例，封装请求相对简单，只作为示例，不做深究。</p><ul><li><p><strong>接口的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口，根据城市名称获取对应天气，切换这里的Bean对象要与返回的Json对象对应，因为我们是通过Gson来进行对象转化</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"weather_mini"</span>)</span><br><span class="line"><span class="function">Observable&lt;WeatherBean&gt; <span class="title">queryCityWeatherRX1</span><span class="params">(@Query(<span class="string">"city"</span>)</span> String city)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>请求示例与数据解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取上海的天气，注意线程之间的切换，主线程中做耗时操作会抛出异常</span></span><br><span class="line">RetrofitManager.getInstance().getApiServices(<span class="keyword">this</span>).queryCityWeatherRX1(<span class="string">"上海"</span>)</span><br><span class="line">               .subscribeOn(Schedulers.io()) <span class="comment">//io线程发起网络请求</span></span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread()) <span class="comment">//主线程处理结果</span></span><br><span class="line">               .subscribe(<span class="keyword">new</span> Observer&lt;WeatherBean&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(WeatherBean weatherBean2)</span> </span>&#123;</span><br><span class="line">                   Log.i(<span class="string">"wd_re"</span>, <span class="string">"getYesterday = "</span> + weatherBean2.getData().getYesterday());</span><br><span class="line">                   Log.i(<span class="string">"wd_re"</span>, <span class="string">"getCity = "</span> + weatherBean2.getData().getCity());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                       Log.i(<span class="string">"wd_re"</span>, <span class="string">"请求失败 : "</span>+e.toString());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       Log.i(<span class="string">"wd_re"</span>, <span class="string">"请求成功"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求结果</span></span><br><span class="line">getYesterday = YesterdayBean&#123;date=<span class="string">'13日星期一'</span>, high=<span class="string">'高温 19℃'</span>, fx=<span class="string">'东南风'</span>, low=<span class="string">'低温 14℃'</span>, fl=<span class="string">'&lt;![CDATA[&lt;3级]]&gt;'</span>, type=<span class="string">'小雨'</span>&#125;</span><br><span class="line">getCity = 上海</span><br><span class="line">请求成功</span><br></pre></td></tr></table></figure></li><li><p><strong>线程问题</strong><br>如果我们做请求网络等耗时操作时，直接在主线程中进行，即请求时去除<strong><code>.subscribeOn(Schedulers.io()</code></strong>，<br>会出现如下错误：<strong><code>android.os.NetworkOnMainThreadException</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出现线程错误 : android.os.NetworkOnMainThreadException</span></span><br><span class="line"> RetrofitManager.getInstance().getApiServices(<span class="keyword">this</span>).queryCityWeatherRX1(<span class="string">"上海"</span>)</span><br><span class="line">                    <span class="comment">//.subscribeOn(Schedulers.io())//io线程发起网络请求</span></span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())<span class="comment">//主线程处理结果</span></span><br><span class="line">                    .subscribe()</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-重点推荐：RxJava2-0的系列文章"><a href="#4-重点推荐：RxJava2-0的系列文章" class="headerlink" title="4.重点推荐：RxJava2.0的系列文章"></a>4.重点推荐：RxJava2.0的系列文章</h4><p>这是一个关于RxJava2.0的系列教程，很有学习的价值，我的例子也是参考而来，重点推荐大家看下。<br><a href="http://www.jianshu.com/p/464fa025229e" target="_blank" rel="noopener">给初学者的RxJava2.0教程</a></p>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxJava系列 - (3)变换符操作</title>
      <link href="/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(3)%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(3)%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><p>前面我们获取到了当前的天气，然后这一次的请求就算结束了。<br>但是当我们在实际操作中，往往有很多嵌套的操作，比如注册、登录逻辑，完成了上一次的请求紧接着根据返回值做下一次请求。<br>这里我们还是以天气为例，请求获取第一个城市的天气之后，再去请求获取第二个城市的天气。</p><h4 id="1-嵌套请求的一般写法"><a href="#1-嵌套请求的一般写法" class="headerlink" title="1.嵌套请求的一般写法"></a>1.嵌套请求的一般写法</h4><p>在一个请求成功的回调中调用另一个请求，从而达到嵌套请求的效果。<br>需求：在方法<strong><code>startRx8()</code></strong>中获取上海的天气，成功之后在<strong><code>onComplete()</code></strong>中调用<strong><code>startRx9()</code></strong>获取北京的天气。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法startRx8()与startRx9()写法完全一致，只是一个请求城市为上海，一个为北京</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startRx8</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">RetrofitManager</span><br><span class="line">    .getInstance()</span><br><span class="line">    .getApiServices(context).queryCityWeatherRX1(<span class="string">"上海"</span>)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())<span class="comment">//io线程发起网络请求</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())<span class="comment">//主线程处理结果</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;WeatherBean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(WeatherBean weatherBean2)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"请求成功"</span>);</span><br><span class="line">            startRx9(context);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很显然，在之前我们这样的请求方式可以说很常见，但是当我们学会使用RxJava中的变换操作符之后，将会发生巨大的变化。</p><hr><a id="more"></a><h4 id="2-Map变换操作符"><a href="#2-Map变换操作符" class="headerlink" title="2.Map变换操作符"></a>2.Map变换操作符</h4><p>map是RxJava中最简单的一个变换操作符，它的作用是：<strong>对上游发送的每一个事件应用一个函数Function，使得每个事件都能按照这个指定的函数去进行对象的变化</strong>，用水管，模型来看就是：<br><img src="https://i.loli.net/2019/10/30/VkwHvUZsEX5mjJi.png" alt="map"></p><p>map中的Function函数将上游的圆形事件变化为矩形事件，所以下游接收时获得的就是矩形事件，有点偷梁换柱的意思。<br>用简单的代码示例来看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//原始数据为int类型的100、200</span></span><br><span class="line">                e.onNext(<span class="number">100</span>);</span><br><span class="line">                e.onNext(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//Function中变换数据为String类型</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Change int to string : "</span>+integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//请求完成之后收到结果</span></span><br><span class="line">                Log.i(TAG, <span class="string">"请求结束 ： "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">100</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">200</span></span><br></pre></td></tr></table></figure></p><p>从日志结果我们可以看到，本来是Integer类型的数据，通过map转换之后，编程了String类型的。map可以将上游发送的事件转换成任意的类型，只要你喜欢。</p><hr><h4 id="3-FlatMap变换操作符"><a href="#3-FlatMap变换操作符" class="headerlink" title="3.FlatMap变换操作符"></a>3.FlatMap变换操作符</h4><p>flatMap是一个相比map更加强大的转换操作符，如果map是一对一，那么flatMap就是多对更多。<br><strong>1.如何理解</strong><br>在<a href="http://www.jianshu.com/p/128e662906af" target="_blank" rel="noopener">给初学者的RxJava2.0教程(三)</a>的文章中是这样描述的：<strong>FlatMap将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里.</strong></p><p><strong>2.自我理解</strong><br>可是经过自己的琢磨，我理解的就有别于上面的描述：<strong>FlatMap将上游Observable发送的N个事件，按照Function中指定的数目M，将上游事件一一拆分为M个子事件，然后无序的整合到新的Observable中继续发送</strong></p><p><strong>3.水管模型解释</strong><br>虽然描述理解不同，但是管道这个模型图还是理解的很到位的。<br><img src="https://i.loli.net/2019/10/30/RZtuVk7rMwyi3GH.png" alt="Alt text"></p><p>注意上游事件的颜色、颜色、颜色！！！<br>上游发送了1、2、3三个圆形事件，中间的flatMap是将一个圆形事件转换成一个三角形事件和一个矩形事件并组合成新的上游Observable。<br>再来分解看下转换的流程：<br><img src="https://i.loli.net/2019/10/30/X71eYfZiJQSvwOE.png" alt="Alt text"></p><p>上游每发送一个事件, flatMap都将创建一个新的水管, 然后发送转换之后的新的事件, 下游接收到的就是这些新的水管发送的数据. 这里需要注意的是：<strong>flatMap并不保证事件的顺序, 也就是图中所看到的, 并不是事件1就在事件2的前面</strong>.</p><p><strong>4.代码中看流程</strong><br>还不能理解的我们就从代码中再琢磨一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="number">100</span>);</span><br><span class="line">                e.onNext(<span class="number">200</span>);</span><br><span class="line">                e.onNext(<span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//这里决定事件拆分个数 </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    list.add(<span class="string">"Change int to string : "</span> + integer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//生成新的上游Observable对象</span></span><br><span class="line">                <span class="keyword">return</span>  Observable.fromIterable(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"请求结束 ： "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">100</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">100</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">200</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">200</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">300</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">300</span></span><br></pre></td></tr></table></figure></p><p>我们上面说flatMap并不保证事件顺序，但是从日志中看到的却是100、200、300这样按照顺序来的，明显和我们的预期不符啊。<br>不用着急，本质上flatMap是无序的，只是上面的日志恰好按顺序打印了，我们可以通过<strong><code>Observable.fromIterable(list).delay(1000, TimeUnit.MILLISECONDS);</code></strong>方法，延时一点可以比较有效的看到无序的事件发送结果(可是我还是没看到无序的日志，不知道什么gui)。</p><hr><h4 id="4-concatMap变换操作符"><a href="#4-concatMap变换操作符" class="headerlink" title="4. concatMap变换操作符"></a>4. concatMap变换操作符</h4><p>concatMap和flatMap的不同就在于：<strong>concatMap是有序的、有序的、有序的</strong>，不管是否延时，都是有序的。<br>我们可以copy上面的同样的代码，将flatMap替换为concatMap，得到一个有序的日志结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="number">100</span>);</span><br><span class="line">                e.onNext(<span class="number">200</span>);</span><br><span class="line">                e.onNext(<span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//这里决定事件拆分个数 </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    list.add(<span class="string">"Change int to string : "</span> + integer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//生成新的上游Observable对象</span></span><br><span class="line">                <span class="keyword">return</span>  Observable.fromIterable(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"请求结束 ： "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">100</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">100</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">200</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">200</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">300</span></span><br><span class="line">I/RxJava: 请求结束 ： Change <span class="keyword">int</span> to string : <span class="number">300</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="5-实际操作"><a href="#5-实际操作" class="headerlink" title="5. 实际操作"></a>5. 实际操作</h4><p>还是上面的请求：获取到上海的天气之后，紧接着获取北京的天气情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">RetrofitManager.getInstance().getApiServices(context).queryCityWeatherRX1(<span class="string">"上海"</span>)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())<span class="comment">//io线程发起网络请求</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())<span class="comment">//主线程处理结果</span></span><br><span class="line">        .doOnNext(<span class="keyword">new</span> Consumer&lt;WeatherBean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(WeatherBean weatherBean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"上海getCity = "</span> + weatherBean.getData().getCity());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .observeOn(Schedulers.io())</span><br><span class="line">        .flatMap(<span class="keyword">new</span> Function&lt;WeatherBean, ObservableSource&lt;WeatherBean&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> ObservableSource&lt;WeatherBean&gt; <span class="title">apply</span><span class="params">(WeatherBean weatherBean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"转换中-------------------------------"</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"getCity = "</span> + weatherBean.getData().getCity());</span><br><span class="line">                Log.i(TAG, <span class="string">"转换中-------------------------------"</span>);</span><br><span class="line">      <span class="keyword">return</span> RetrofitManager.getInstance().getApiServices(context).queryCityWeatherRX1(<span class="string">"北京"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;WeatherBean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(WeatherBean weatherBean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"北京getCity = "</span> + weatherBean.getData().getCity());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: 上海getCity = 上海</span><br><span class="line">I/RxJava: 转换中-------------------------------</span><br><span class="line">I/RxJava: getCity = 上海</span><br><span class="line">I/RxJava: 转换中-------------------------------</span><br><span class="line">I/RxJava: 北京getCity = 北京</span><br></pre></td></tr></table></figure></p><p>代码中我们利用<code>flatMap</code>进行转换，也获取到了第一次请求到的城市-上海的天气情况，我们可以在这里面做一些必要的事情，然后紧接着进行第二次的请求，获取城市-北京的天气情况，最后在<code>subscribe</code>中获取返回数据。</p>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxJava系列 - (4)zip操作符</title>
      <link href="/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(4)zip%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(4)zip%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><h4 id="1-zip操作符说明"><a href="#1-zip操作符说明" class="headerlink" title="1.zip操作符说明"></a>1.zip操作符说明</h4><p>RxJava中的操作符多种多样，这里介绍的是名为：zip的操作符。<br><strong><code>zip</code></strong>可以通过一个函数Function将多个Observable发送的事件按顺序组合到一起，然后再依次发送这些组合事件，并且发送组合事件的个数与组合前的Observable中发送事件最少的一致。</p><p>通过管道模型图来理解下：<br><img src="https://i.loli.net/2019/10/30/uePrYAc5Dg6psxJ.png" alt="Alt text"></p><p>上图中与以往不同之处在于我们上游存在两个管道。<br>管道1发送圆形事件，管道2发送三角形事件，通过<strong><code>zip操作符</code></strong>的组合后变为了矩形事件。<br>为了加强理解，我们再看下分解动作：<br><img src="https://i.loli.net/2019/10/30/lbFCeW4hcPdwzGI.png" alt="Alt text"></p><p>从分解动作中，我们获取到以下几个重要信息：</p><ul><li><strong>组合过程是有序且一一对应的。</strong>组合是分别从管道1、管道2中按顺序分别取出一个事件，组合成新的事件，所有上游事件只能使用一次并且严格遵守顺序。所以不会出现管道1中的事件1和管道2中的事件B进行组合的情况。</li><li><strong>下游组合事件的最大数量由上游管道发送的最小数量决定。</strong>很容易理解就是既然是组合事件，两个上游组合为一个上游且不重复，所以上游最少的事件数量就决定了下游组合事件的数量。</li></ul><hr><a id="more"></a><h4 id="2-zip操作符使用"><a href="#2-zip操作符使用" class="headerlink" title="2.zip操作符使用"></a>2.zip操作符使用</h4><p>按照上面的理解，我们撸一段代码看看什么情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上游1-发送了三个事件和complete</span></span><br><span class="line">Observable&lt;String&gt; o1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- o1 send 1 ----------"</span>);</span><br><span class="line">        e.onNext(<span class="string">"The One event 1"</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- o1 send 2 ----------"</span>);</span><br><span class="line">        e.onNext(<span class="string">"The One event 2"</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- o1 send 3 ----------"</span>);</span><br><span class="line">        e.onNext(<span class="string">"The One event 3"</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- o1 onComplete ----------"</span>);</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//上游2-发送了两个事件和complete</span></span><br><span class="line">Observable&lt;Integer&gt; o2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"******* o2 send 1 *******"</span>);</span><br><span class="line">        e.onNext(<span class="number">100</span>);leep(<span class="number">2000</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"******** o2 send 2 ********"</span>);</span><br><span class="line">        e.onNext(<span class="number">200</span>);sleep(<span class="number">2000</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"******** o2 onComplete ********"</span>);</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//zip合并事件，注意BiFunction函数中的参数要对应，前面的参数与上游Observable对应，最后一个参数与合并后返回的类型对应</span></span><br><span class="line">Observable.zip(o1, o2, <span class="keyword">new</span> BiFunction&lt;String,Integer,String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String o, Integer o2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- zip ----------"</span>);</span><br><span class="line">        <span class="keyword">return</span> o+o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- zip onNext ----------"</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"---------- zip complete ----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">1</span> ----------</span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">2</span> ----------</span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">3</span> ----------</span><br><span class="line">I/RxJava: ---------- o1 onComplete ----------</span><br><span class="line">I/RxJava: ******* o2 send <span class="number">1</span> *******</span><br><span class="line">I/RxJava: ---------- zip ----------</span><br><span class="line">I/RxJava: ---------- zip onNext ----------The One event <span class="number">1100</span></span><br><span class="line">I/RxJava: ******** o2 send <span class="number">2</span> ********</span><br><span class="line">I/RxJava: ---------- zip ----------</span><br><span class="line">I/RxJava: ---------- zip onNext ----------The One event <span class="number">2200</span></span><br><span class="line">I/RxJava: ******** o2 onComplete ********</span><br><span class="line">I/RxJava: ---------- zip complete ----------</span><br></pre></td></tr></table></figure></p><p>看起来不错，该执行的都执行了，该输出的日志信息看得也很清晰。<br>但是有没有发现，<strong>为嘛o1发送完了之后，才轮到o2发送呢？说好的你一个，我一个，孕育新生命的呢？</strong></p><ul><li><strong>o1、o2都睡那么一小会看看</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; o1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 send 1 ----------"</span>);</span><br><span class="line">                e.onNext(<span class="string">"The One event 1"</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 send 2 ----------"</span>);</span><br><span class="line">                e.onNext(<span class="string">"The One event 2"</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 send 3 ----------"</span>);</span><br><span class="line">                e.onNext(<span class="string">"The One event 3"</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 onComplete ----------"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Observable&lt;Integer&gt; o2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"******* o2 send 1 *******"</span>);</span><br><span class="line">                e.onNext(<span class="number">100</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"******** o2 send 2 ********"</span>);</span><br><span class="line">                e.onNext(<span class="number">200</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"******** o2 onComplete ********"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">1</span> ----------</span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">2</span> ----------</span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">3</span> ----------</span><br><span class="line">I/RxJava: ---------- o1 onComplete ----------</span><br><span class="line">I/RxJava: ******* o2 send <span class="number">1</span> *******</span><br><span class="line">I/RxJava: ---------- zip ----------</span><br><span class="line">I/RxJava: ---------- zip onNext ----------The One event <span class="number">1100</span></span><br><span class="line">I/RxJava: ******** o2 send <span class="number">2</span> ********</span><br><span class="line">I/RxJava: ---------- zip ----------</span><br><span class="line">I/RxJava: ---------- zip onNext ----------The One event <span class="number">2200</span></span><br><span class="line">I/RxJava: ******** o2 onComplete ********</span><br><span class="line">I/RxJava: ---------- zip complete ----------</span><br></pre></td></tr></table></figure></li></ul><p>看了这日志结果，此刻我的内心是奔溃的，睡了一下也还是o1先执行完成，才轮到o2。那我们想想还有什么可以改变的呢？</p><ul><li><strong>比如说切换一下o1、o2所在的线程</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; o1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 send 1 ----------"</span>);</span><br><span class="line">                e.onNext(<span class="string">"The One event 1"</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 send 2 ----------"</span>);</span><br><span class="line">                e.onNext(<span class="string">"The One event 2"</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 send 3 ----------"</span>);</span><br><span class="line">                e.onNext(<span class="string">"The One event 3"</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"---------- o1 onComplete ----------"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">        Observable&lt;Integer&gt; o2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"******* o2 send 1 *******"</span>);</span><br><span class="line">                e.onNext(<span class="number">100</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"******** o2 send 2 ********"</span>);</span><br><span class="line">                e.onNext(<span class="number">200</span>);</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"******** o2 onComplete ********"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">1</span> ----------</span><br><span class="line">I/RxJava: ******* o2 send <span class="number">1</span> *******</span><br><span class="line">I/RxJava: ---------- zip ----------</span><br><span class="line">I/RxJava: ---------- zip onNext ----------The One event <span class="number">1100</span></span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">2</span> ----------</span><br><span class="line">I/RxJava: ******** o2 send <span class="number">2</span> ********</span><br><span class="line">I/RxJava: ---------- zip ----------</span><br><span class="line">I/RxJava: ---------- zip onNext ----------The One event <span class="number">2200</span></span><br><span class="line">I/RxJava: ---------- o1 send <span class="number">3</span> ----------</span><br><span class="line">I/RxJava: ******** o2 onComplete ********</span><br><span class="line">I/RxJava: ---------- zip complete ----------</span><br><span class="line">I/RxJava: ---------- o1 onComplete ----------</span><br></pre></td></tr></table></figure></li></ul><p>这下看起来就很舒服了。<br>我们使得<strong>o1、o2在不同的io线程中执行，</strong>然后可以看到<strong>o1发送事件之后，o2就跟着发送事件，然后zip执行操作，如此循环，直到某个管道事件发送结束</strong>。</p><p>我们看到o1原本发送了<strong>三个事件+complete</strong>，o2原本发送了<strong>两个事件+complete</strong>，但是注意看，我们只输出了两个包含<br><strong><code>--- zip onNext ---</code></strong>的日志，然后<strong>o1发送事件3时，o2就直接onComplete了</strong>，这就说明<strong>o2的所有事件发送完了之后，不会再和o1的事件组合了，即使o1还会发送剩余的事件。</strong></p><ul><li><strong>Thread.sleep()对发送事件的影响</strong><br>在<strong>给初学者的RxJava2.0教程(四)</strong>中o1的剩余事件也没有发送了，而上面的日志中可以看到o1剩余的事件也发送了，即使没什么意义了。<br>这里的区别在于我使用的睡觉方式不同，使用的是：<strong>SystemClock.sleep(2000)</strong>，因为使用<strong>Thread.sleep()</strong>在这里会遇到一个问题：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>-<span class="number">27</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">21.961</span> <span class="number">9942</span>-<span class="number">10148</span>/? E/AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-<span class="number">1</span></span><br><span class="line"> Process: com.wd.rm, PID: <span class="number">9942</span></span><br><span class="line"> io.reactivex.exceptions.UndeliverableException: java.lang.InterruptedException</span><br><span class="line">     at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:<span class="number">349</span>)</span><br><span class="line">     at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onError(ObservableCreate.java:<span class="number">74</span>)</span><br><span class="line">     at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:<span class="number">43</span>)</span><br><span class="line">     at io.reactivex.Observable.subscribe(Observable.java:<span class="number">10910</span>)</span><br><span class="line">     at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:<span class="number">96</span>)</span><br><span class="line">     at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:<span class="number">452</span>)</span><br><span class="line">     at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:<span class="number">61</span>)</span><br><span class="line">     at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:<span class="number">52</span>)</span><br><span class="line">     at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">237</span>)</span><br><span class="line">     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:<span class="number">272</span>)</span><br><span class="line">     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1133</span>)</span><br><span class="line">     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">607</span>)</span><br><span class="line">     at java.lang.Thread.run(Thread.java:<span class="number">761</span>)</span><br><span class="line">  Caused by: java.lang.InterruptedException</span><br><span class="line">     at java.lang.Thread.sleep(Native Method)</span><br><span class="line">     at java.lang.Thread.sleep(Thread.java:<span class="number">371</span>)</span><br><span class="line">     at java.lang.Thread.sleep(Thread.java:<span class="number">313</span>)</span><br><span class="line">     at com.wd.ru.rx.RxJavaTest$<span class="number">23</span>.subscribe(RxJavaTest.java:<span class="number">455</span>)</span><br><span class="line">     at io.reactivex.internal.operators.observable.ObservableCreate.subscribeActual(ObservableCreate.java:<span class="number">40</span>)</span><br><span class="line">     at io.reactivex.Observable.subscribe(Observable.java:<span class="number">10910</span>) </span><br><span class="line">     at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:<span class="number">96</span>) </span><br><span class="line">     at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:<span class="number">452</span>) </span><br><span class="line">     at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:<span class="number">61</span>) </span><br><span class="line">     at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:<span class="number">52</span>) </span><br><span class="line">     at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">237</span>) </span><br><span class="line">     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:<span class="number">272</span>) </span><br><span class="line">     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1133</span>) </span><br><span class="line">     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">607</span>) </span><br><span class="line">     at java.lang.Thread.run(Thread.java:<span class="number">761</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>建议看下 给初学者的RxJava2.0教程(四) 评论，我说的也不清楚，一脸懵逼。。。</code></strong></p><hr><h4 id="3-实践"><a href="#3-实践" class="headerlink" title="3.实践"></a>3.实践</h4><p>还是之前获取北京和上海的天气的例子，我们同时获取两个城市的天气，然后拿到两份数据进行其他操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上海</span></span><br><span class="line">Observable&lt;WeatherBean&gt; observable1 = RetrofitManager.getInstance().getApiServices(context).queryCityWeatherRX1(<span class="string">"上海"</span>).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"><span class="comment">//北京</span></span><br><span class="line">Observable&lt;WeatherBean&gt; observable2 = RetrofitManager.getInstance().getApiServices(context).queryCityWeatherRX1(<span class="string">"北京"</span>).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"><span class="comment">//zip操作</span></span><br><span class="line">Observable.zip(observable1, observable2, <span class="keyword">new</span> BiFunction&lt;WeatherBean, WeatherBean, String&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(WeatherBean weatherBean, WeatherBean weatherBean2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           String c1 = weatherBean.getData().getCity();</span><br><span class="line">           String c2 = weatherBean2.getData().getCity();</span><br><span class="line">           <span class="keyword">return</span> c1+c2;</span><br><span class="line">       &#125;</span><br><span class="line">        &#125;).observeOn(AndroidSchedulers.mainThread()).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"获取最后的数据: "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志结果</span></span><br><span class="line">I/RxJava: 获取最后的数据: 上海北京</span><br></pre></td></tr></table></figure></p><p>这个例子比较适合那种需要同时请求接口，但是互不依赖的两组数据，正好第三方都需要他们。</p>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RxJava系列 - (5)Backpressure &amp; Flowable</title>
      <link href="/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(5)Backpressure%20&amp;%20Flowable/"/>
      <url>/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20(5)Backpressure%20&amp;%20Flowable/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><h3 id="1-Backpressure"><a href="#1-Backpressure" class="headerlink" title="1. Backpressure"></a>1. Backpressure</h3><p><strong>Backpressure</strong>叫做什么背压式，我还以为是按摩呢。<br>先不说背压什么的，我们看下由<strong>zip操作符</strong>延伸来的问题</p><ul><li><p><strong>zip延伸问题</strong><br>我们学习zip的时候，可以看到他可以将多个上游发送的事件组合起来，然后在形成新的事件发送给下游。那这样就会产生各种各样的问题，比如：<strong>上游水管A发送事件的速度很快，而水管B发送事件的速度很慢，</strong>假如水管A发送了100个事件，而水管B才发送了1个事件，组合之后，水管A还剩下了99个已发送的事件，<strong>那这些事件去哪里呢？不可能平白消失吧？</strong></p></li><li><p><strong>水缸存储事件</strong><br>当然不会消失，zip给每一个上游的水管都准备了一个大水缸，用来储存这些还来不及进行组合的事件。我们用水管图表示就是这样的：<br><img src="https://i.loli.net/2019/10/30/SuBF4zjgNWxq9HA.png" alt="Alt text"></p></li></ul><p>上面那个蓝色的正方形就是水缸，上游水管发送的事件都放到里面，然后水缸之间的事件一一组合，当某个水缸空了的时候就处于等待的状态。</p><p>这个水缸有个特点：<strong>事件是按照顺序保存的，遵循先进先出的原则，和队列是一样的，Zip的内部源码就是如此实现的。</strong></p><ul><li><strong>水缸漏水</strong><br>再大的水缸也会有装满的时候。<br>上游如果无限制的发送事件，水缸里总会被事件填满知道溢出，我们可以从这个教程中看到漏水事件是什么个情况：<br><a href="http://www.jianshu.com/p/0f2d6c2387c9" target="_blank" rel="noopener">给初学者的RxJava2.0教程(五)</a></li></ul><hr><a id="more"></a><h3 id="2-使用Observable解决上下游流速不均问题"><a href="#2-使用Observable解决上下游流速不均问题" class="headerlink" title="2. 使用Observable解决上下游流速不均问题"></a>2. 使用Observable解决上下游流速不均问题</h3><p>先看一个例子：无限循环发送事件，导致内存溢出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;  <span class="comment">//无限循环发送事件</span></span><br><span class="line">                    emitter.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">               .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Log.d(TAG, <span class="string">""</span> + integer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li><strong>方案1：使用filter进行过滤，减少下游接收事件数量</strong><br>上面的例子中，上游无限发送事件，下游不管是不是自己需要的，统统的装进了自己的水缸，导致内存溢出了，解决这种情况的一种方式就是：只选择符合自己条件的事件装进水缸，其他的事件忽略不计。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">                    emitter.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">                .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> integer % <span class="number">10</span> == <span class="number">0</span>;<span class="comment">//只要能被10整除的事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">""</span> + integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>这里使用了filter函数过滤了不能被10整除的事件，乍一看好像满足了我们的需求。这种通过过滤减少放进水缸数量的方式虽然满足少部分情景，但存在一个问题:<strong>丢失了大部分的事件</strong>，那你也许会像，下游不行，那从上游入手也可以呀！</p><ul><li><strong>方案2：减缓上游发送事件的速度</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">                    emitter.onNext(i);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">//每次发送完事件延时2秒</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">           .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">           .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Log.d(TAG, <span class="string">""</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>这里每发送一个事件，延时2s再发送下一个事件，虽然数量没变，但是给了下游足够的时间来从水缸中取出事件进行处理，不至于导致水缸爆满的情况。</p><hr><h3 id="3-使用Flowable解决上下游流速不均问题"><a href="#3-使用Flowable解决上下游流速不均问题" class="headerlink" title="3. 使用Flowable解决上下游流速不均问题"></a>3. 使用Flowable解决上下游流速不均问题</h3><ul><li><strong>首先了解一下Observable和Flowable使用时的区别</strong><blockquote><p>Observable  对应  Observer ，  Flowable  对应  Subscriber</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; upstream = Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"emit 1"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"emit 2"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"emit 3"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"emit complete"</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR); <span class="comment">//增加了一个参数</span></span><br><span class="line"></span><br><span class="line">        Subscriber&lt;Integer&gt; downstream = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                s.request(Long.MAX_VALUE);  <span class="comment">//注意这句代码</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                 Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        upstream.subscribe(downstream);</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个上游Flowable和一个下游Subscriber，与Observable的不同之处在于Flowable多了一个参数：<strong>BackpressureStrategy.ERROR</strong>，这个参数指的是：<strong>FLowable选择的背压策略，这里使用ERROR策略，即当上下游流速不均时，直接抛出MissingBackpressureException异常</strong>，其他策略后面继续讲解。</p><p>另一个区别是：下游的<strong>onSubscribe</strong>方法中，传递的不再是<code>Disposable</code>，而是<code>Subscription</code>，而两者的区别在于：</p><blockquote><ol><li>Disposbale.dispose()方法切断水管，Subscription.cancel()切断水管；</li><li>Subscription新增一个方法 void request(long n)，该方法表示的是：<code>下游每次能处理多少个事件</code></li></ol></blockquote><ul><li><strong>void request(long n)的简单说明和重要性</strong><br>request(long n)方法表示的是下游每次能处理多少个事件，不设置是表示没有处理能力，不管是同步订阅还是异步订阅，request(long n)的效力都一样，下面分几种情况看下request(long n)对事件的影响。<blockquote><p><code>Flowable采用的是响应式拉取来处理事件，下游通过调用request()方法来设置从上游拉取事件的数量，没有处理能力时就不去拉取事件进行处理。</code></p><p><strong>1. 不调用request(long n)方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p><code>1. 同步订阅：下游没有处理能力，不能处理上游发送的任何事件，此时会直接抛出MissingBackpressureException异常；</code><br>原因：上游发送了事件，下游又没有能力处理，那总不能一直等待，如果是在主线程那就会卡主页面，所以就直接抛出异常，提醒我们要进行request的调用。</p><p><code>2. 异步订阅：下游没有处理能力，不能处理上游发送的任何事件，但是上游会正常发送完不超过128个事件，也不会抛出异常，如果超过128个，则直接抛出MissingBackpressureException异常。</code><br>原因：上游能发送不超过128个事件却不抛出异常是因为Flowable中默认设置水缸大小为128，当上下游不在同一个线程中时，上游发送的事件会先保存到水缸中，下游虽然没有调用request方法，但是并不影响默认水缸存储事件，但是下游不处理事件式，超过了128个事件，水缸已经满了就会抛出异常。</p></blockquote><h3 id="4-背压策略"><a href="#4-背压策略" class="headerlink" title="4. 背压策略"></a>4. 背压策略</h3><p>上面说的只是在Flowable使用<code>BackpressureStrategy.ERROR</code>策略时出现的情况，其实BackpressureStrategy还有其他几种情况可供选择，具体请查看：RxJava-Observables之间的区别：4. 背压(BackpressureStrategy)策略之间的区别</p>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Retrofit2.0系列 - (3)简单封装请求</title>
      <link href="/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97-(3)%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/"/>
      <url>/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97-(3)%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/Retrofit2.0%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3/">Retrofit 2.0系列 - (1)玩转注解</a><br><a href="https://www.syncxiao.com/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AA%E5%99%A8/">Retrofit 2.0系列 - (2)全面解析拦截器</a><br><a href="https://www.syncxiao.com/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97-&#40;3&#41;%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/">Retrofit2.0系列 - (3)简单封装请求</a></p><hr><h4 id="1-请求接口的定义"><a href="#1-请求接口的定义" class="headerlink" title="1. 请求接口的定义"></a>1. 请求接口的定义</h4><p><strong>使用天气接口进行调试，定义接口时要注意几点：</strong></p><ul><li>使用GET或者POST方式请求时，注解使用的是不同的</li><li>GET形式的接口：weather_mini?city={city}，注意接口中参数的传递方式</li><li>Call&lt;&gt;函数中的参数与实际调用的要保持一致，默认的ResponseBody返回的是json形式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GApiServices</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误方式</span></span><br><span class="line"><span class="comment">     * weather_mini?city=&#123;city&#125;</span></span><br><span class="line"><span class="comment">     * 请求参数在？号后面，此种方式需用<span class="doctag">@Query</span>，否则抛出如下异常，并且参数不需要在<span class="doctag">@GET</span>()里面声明</span></span><br><span class="line"><span class="comment">     * java.lang.IllegalArgumentException: URL query string "city=&#123;city&#125;" must not have replace block. For dynamic query parameters use <span class="doctag">@Query</span>.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"weather_mini?city=&#123;city&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">queryCityWeather1</span><span class="params">(@Query(<span class="string">"city"</span>)</span> String city)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  完整的请求地址</span></span><br><span class="line"><span class="comment">     *  http://wthrcdn.etouch.cn/weather_mini?city=%E4%B8%8A%E6%B5%B7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"weather_mini"</span>)</span><br><span class="line">    <span class="function">Call&lt;WeatherBean&gt; <span class="title">queryCityWeather2</span><span class="params">(@Query(<span class="string">"city"</span>)</span> String city)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><hr><h4 id="2-请求的统一封装"><a href="#2-请求的统一封装" class="headerlink" title="2.请求的统一封装"></a>2.请求的统一封装</h4><p><strong>关于请求封装的几点说明：</strong></p><ul><li>请求使用单例的形式</li><li>提供了可替换域名的接口</li><li>加入了自定义的请求头拦截器</li><li>加入了okhttp中的日志拦截器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String BASE_URL = <span class="string">"http://wthrcdn.etouch.cn/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RetrofitManager manager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit retrofit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RetrofitManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RetrofitManager.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    manager = <span class="keyword">new</span> RetrofitManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可替换域名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GApiServices <span class="title">getApiServices</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApiServices(context, BASE_URL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可替换域名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GApiServices <span class="title">getApiServices</span><span class="params">(Context context, String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!url.equals(BASE_URL))&#123;</span><br><span class="line">            retrofit = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retrofit == <span class="keyword">null</span>) &#123;</span><br><span class="line">            retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(url).addConverterFactory(GsonConverterFactory.create(<span class="keyword">new</span></span><br><span class="line">                    GsonBuilder().setDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>).create())).client(getClient(context)).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retrofit.create(GApiServices.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient <span class="title">getClient</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            client = <span class="keyword">new</span> OkHttpClient.Builder().</span><br><span class="line">           <span class="comment">//请求头加入的位置会影响日志拦截器，如果请求头在前，日志的request是可以拦截到头信息，否则拦截不到</span></span><br><span class="line">                    addInterceptor(<span class="keyword">new</span> HeadersInterceptor())</span><br><span class="line">                    <span class="comment">//日志拦截</span></span><br><span class="line">                    .addInterceptor(<span class="keyword">new</span> HttpLoggingInterceptor()</span><br><span class="line">                    .setLevel(HttpLoggingInterceptor.Level.BODY))</span><br><span class="line">                    <span class="comment">//时间可以定义为常量</span></span><br><span class="line">                    .connectTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .writeTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .retryOnConnectionFailure(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-返回数据的统一格式"><a href="#3-返回数据的统一格式" class="headerlink" title="3.返回数据的统一格式"></a>3.返回数据的统一格式</h4><p><strong>既然是统一的请求封装，返回的数据也需要统一格式，这里还是以天气接口返回数据作为示例</strong></p><ul><li><p>天气接口返回的json数据(省略部分数据)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"data"</span>:&#123;</span><br><span class="line">        <span class="string">"yesterday"</span>:&#123;</span><br><span class="line">            <span class="string">"date"</span>:<span class="string">"12日星期四"</span>,</span><br><span class="line">            <span class="string">"high"</span>:<span class="string">"高温 14℃"</span>,</span><br><span class="line">            <span class="string">"fx"</span>:<span class="string">"北风"</span>,</span><br><span class="line">            <span class="string">"low"</span>:<span class="string">"低温 6℃"</span>,</span><br><span class="line">            <span class="string">"fl"</span>:<span class="string">"&lt;![CDATA[&lt;3级]]&gt;"</span>,</span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"小雨"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"status"</span>:<span class="number">1000</span>,</span><br><span class="line">    <span class="string">"desc"</span>:<span class="string">"OK"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义基础的bean，不管哪个接口都会返回<strong><code>status、desc、data数据</code></strong>等固定的字段</p></li><li><p>使用T泛型，子类只需要关心data数据中的具体字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体的实现类，继承自BaseBean，然后根据返回数据中的data数据定义字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherBean2</span> <span class="keyword">extends</span> <span class="title">BaseBean</span>&lt;<span class="title">WeatherBean2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> YesterdayBean yesterday;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> YesterdayBean <span class="title">getYesterday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> yesterday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">YesterdayBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略具体的字段.......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际调用接口请求数据,处理回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RetrofitManager.getInstance().getApiServices(<span class="keyword">this</span>).queryCityWeather2(<span class="string">"上海"</span>).enqueue(<span class="keyword">new</span> Callback&lt;WeatherBean2&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;WeatherBean2&gt; call, Response&lt;WeatherBean2&gt; response)</span> </span>&#123;</span><br><span class="line">               WeatherBean2 bean = response.body();</span><br><span class="line">               Log.i(<span class="string">"wd_re"</span>, <span class="string">"getStatus = "</span> + bean.getStatus());</span><br><span class="line">               Log.i(<span class="string">"wd_re"</span>, <span class="string">"getDesc = "</span> + bean.getDesc());</span><br><span class="line">               </span><br><span class="line">               WeatherBean2.YesterdayBean weatherBean2 =  bean.getData().getYesterday();</span><br><span class="line">               Log.i(<span class="string">"wd_re"</span>, <span class="string">"日期 = "</span> + weatherBean2.getDate());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;WeatherBean2&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-自定义回调函数Callback，简化返回操作"><a href="#4-自定义回调函数Callback，简化返回操作" class="headerlink" title="4.自定义回调函数Callback，简化返回操作"></a>4.自定义回调函数Callback，简化返回操作</h4><p>看到上面的请求结果，成功之后还是在<strong><code>onResponse</code></strong>中做的处理，还是太过复杂，不太符合我们的需求。</p><ul><li>需求：成功进入onSuccess回调，失败进入onFailure回调，并且单个接口不关心怎么进入，只需要处理对应的回调逻辑</li></ul><p><strong>改进方式：</strong></p><ul><li>自定义callback函数，统一处理返回结果</li><li><p>回调函数中返回相应的code以及返回结果的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful()) &#123;<span class="comment">//[200..300)</span></span><br><span class="line">                BaseBean&lt;T&gt; baseBean = (BaseBean&lt;T&gt;) response.body();</span><br><span class="line">                T bean = baseBean.getData();</span><br><span class="line">                onSuccess(response.code(), bean);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onFailure(response.code(), response.message());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">        onNetFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义抽象方法，回调中根据情况选择执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> code, T response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> code, String errMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onNetFailure</span><span class="params">(Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际调用接口请求数据，处理回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RetrofitManager.getInstance().getApiServices(<span class="keyword">this</span>).queryCityWeather2(<span class="string">"上海"</span>)</span><br><span class="line">.enqueue(<span class="keyword">new</span> BaseCallback&lt;WeatherBean2&gt;()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> code, WeatherBean2 response)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//根据定义的对象直接获取参数</span></span><br><span class="line">              Log.i(<span class="string">"wd_re"</span>, <span class="string">"getYesterday = "</span> + response.getYesterday().toString());</span><br><span class="line">              Log.i(<span class="string">"wd_re"</span>, <span class="string">"getCity = "</span> + response.getCity());</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> code, String errMsg)</span> </span>&#123;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNetFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="5-存在问题以及需要改进之处"><a href="#5-存在问题以及需要改进之处" class="headerlink" title="5.存在问题以及需要改进之处"></a>5.存在问题以及需要改进之处</h4><ul><li>这里定义的接口都在<strong><code>GApiServices</code></strong> ，假如某一天接口需要写到另一个<strong><code>ApiServices</code></strong> 中，那么<strong><code>getApiServices</code></strong>接口就不能适应修改；</li><li>假如返回数据<strong><code>response.body()</code></strong>返回的数据解析异常，应该提前检测并做好相应的处理；</li><li>一般返回数据的接口中都是<strong><code>&quot;detail&quot;:{ ... }</code></strong>，加入某个接口返回的是数组：<strong><code>&quot;detail&quot;:[]</code></strong>；</li><li>提前对服务端返回结果根据不同的code状态进行判断，减少每次请求时都要判断是否成功、失败；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Retrofit2.0系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 封装请求 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit2.0系列 - (2)全面解析拦截器</title>
      <link href="/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97%20-%20(2)%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97%20-%20(2)%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/Retrofit2.0%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3/">Retrofit 2.0系列 - (1)玩转注解</a><br><a href="https://www.syncxiao.com/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AA%E5%99%A8/">Retrofit 2.0系列 - (2)全面解析拦截器</a><br><a href="https://www.syncxiao.com/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97-&#40;3&#41;%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/">Retrofit2.0系列 - (3)简单封装请求</a></p><hr><h3 id="1-拦截器-Interceptors-定义"><a href="#1-拦截器-Interceptors-定义" class="headerlink" title="1. 拦截器(Interceptors)定义"></a>1. 拦截器(Interceptors)定义</h3><ul><li><strong>拦截器是一种可以用来转换、重试、重写请求的机制</strong></li><li><strong>拦截器被定义为一个接口，其中就包含一个<code>intercept(Chain chain)</code>方法和一个接口<code>interface Chain</code>，使用时重点在于<code>request</code>和<code>proceed(Request request)</code>两个方法</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the connection the request will be executed on. This is only available in the chains</span></span><br><span class="line"><span class="comment">     * of network interceptors; for application interceptors this is always null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><a id="more"></a><h3 id="2-拦截器分类"><a href="#2-拦截器分类" class="headerlink" title="2. 拦截器分类"></a>2. 拦截器分类</h3><p><strong><code>应用拦截器(Application Interceptors)、网络拦截器(NetWork Interceptors)</code></strong></p><h4 id="2-1-应用拦截器-Application-Interceptors"><a href="#2-1-应用拦截器-Application-Interceptors" class="headerlink" title="2.1 应用拦截器(Application Interceptors)"></a>2.1 应用拦截器(Application Interceptors)</h4><ul><li><strong>主要用途：主要用于查看请求信息和返回信息</strong> </li><li><strong>添加方式：</strong>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在OkHttpClient.Builder中添加</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.在OkHttpClient中添加</span></span><br><span class="line">client.interceptors().add(<span class="keyword">new</span> HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY));</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-网络拦截器-NetWork-Interceptors"><a href="#2-2-网络拦截器-NetWork-Interceptors" class="headerlink" title="2.2 网络拦截器(NetWork Interceptors)"></a>2.2 网络拦截器(NetWork Interceptors)</h4><ul><li><strong>主要用途：不仅用于查看请求信息和返回信息，还可以添加、删除、替换请求头信息、改变请求携带的实体</strong> </li><li><strong>添加方式：</strong>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在OkHttpClient.Builder中添加</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addNetworkInterceptor(<span class="keyword">new</span> HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.在OkHttpClient中添加</span></span><br><span class="line">client.networkInterceptors().add(<span class="keyword">new</span> HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY));</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-区别与选择"><a href="#2-3-区别与选择" class="headerlink" title="2.3 区别与选择"></a>2.3 区别与选择</h4><p> <strong>从输出的日志来看，网络拦截器会包含信息更多，如<code>Accept-Encoding: gzip</code>、<code>Host</code>等</strong></p><ul><li><p><strong>应用拦截器</strong></p><pre><code>1. 不必要担心响应和重定向之间的中间响应。2. 通常只调用一次，即使HTTP响应是通过缓存提供的。3.  遵从应用层的最初目的。与OkHttp的注入头部无关，如If-None-Match。4. 允许短路而且不调用Chain.proceed()。5. 允许重试和多次调用Chain.proceed()。</code></pre></li><li><p><strong>网络拦截器</strong></p><pre><code>1. 允许像重定向和重试一样操作中间响应。2. 网络发生短路时不调用缓存响应。3. 在数据被传递到网络时观察数据。4. 有权获得装载请求的连接。</code></pre></li><li><strong><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">Github关于拦截器的说明，并且包含拦截器示例、重写请求、重写响应示例</a></strong></li></ul><hr><h3 id="3-不同类型的拦截器"><a href="#3-不同类型的拦截器" class="headerlink" title="3. 不同类型的拦截器"></a>3. 不同类型的拦截器</h3><h4 id="3-1-日志拦截器"><a href="#3-1-日志拦截器" class="headerlink" title="3.1 日志拦截器"></a>3.1 日志拦截器</h4><p><strong>HttpLoggingInterceptor中提供了四种类型的log日志以供使用，我们也可自己定义自己的log日志拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;</span><br><span class="line"><span class="comment">/** No logs. */</span></span><br><span class="line">    NONE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Logs request and response lines.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Example:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * --&gt; POST /greeting http/1.1 (3-byte body)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;-- 200 OK (22ms, 6-byte body)</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BASIC,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Logs request and response lines and their respective headers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Example:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * --&gt; POST /greeting http/1.1</span></span><br><span class="line"><span class="comment">     * Host: example.com</span></span><br><span class="line"><span class="comment">     * Content-Type: plain/text</span></span><br><span class="line"><span class="comment">     * Content-Length: 3</span></span><br><span class="line"><span class="comment">     * --&gt; END POST</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;-- 200 OK (22ms)</span></span><br><span class="line"><span class="comment">     * Content-Type: plain/text</span></span><br><span class="line"><span class="comment">     * Content-Length: 6</span></span><br><span class="line"><span class="comment">     * &lt;-- END HTTP</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HEADERS,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Logs request and response lines and their respective headers and bodies (if present).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Example:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * --&gt; POST /greeting http/1.1</span></span><br><span class="line"><span class="comment">     * Host: example.com</span></span><br><span class="line"><span class="comment">     * Content-Type: plain/text</span></span><br><span class="line"><span class="comment">     * Content-Length: 3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Hi?</span></span><br><span class="line"><span class="comment">     * --&gt; END POST</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;-- 200 OK (22ms)</span></span><br><span class="line"><span class="comment">     * Content-Type: plain/text</span></span><br><span class="line"><span class="comment">     * Content-Length: 6</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Hello!</span></span><br><span class="line"><span class="comment">     * &lt;-- END HTTP</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BODY</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-自定义日志拦截器"><a href="#3-2-自定义日志拦截器" class="headerlink" title="3.2 自定义日志拦截器"></a>3.2 自定义日志拦截器</h4><p><strong>这里主要是根据自己的需求重新组织<code>logForRequest</code>和<code>logForResponse</code>中日志信息的组成，可以输出想要的请求头信息、请求往返时间、返回参数信息等。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Request request = chain.request();</span><br><span class="line">     <span class="comment">//自定义请求是日志输出格式</span></span><br><span class="line">     logRequest(request);</span><br><span class="line">     <span class="comment">//关键点：让请求继续执行</span></span><br><span class="line">     Response response = chain.proceed(request);</span><br><span class="line">     <span class="comment">//自定义返回时日志输出格式</span></span><br><span class="line">     logResponse(response);</span><br><span class="line">     <span class="keyword">return</span> response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>这里主要看一下自定义的返回时日志的输出<code>logResponse(response)</code>，里面有一个坑需要注意一下</strong></p><ul><li><strong>此方法只是简单的输出URl、头信息、返回body等；</strong></li><li><strong>注意不要跳坑：okhttp中<code>response.body().string()</code>只能有效的调用一次，否则会出现<code>java.lang.IllegalStateException: closed</code>异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logResponse</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringBuffer var0 = <span class="keyword">new</span> StringBuffer(<span class="string">"Response-Start : "</span>);</span><br><span class="line">            <span class="comment">//url</span></span><br><span class="line">            var0.append(<span class="string">"url : "</span> + response.request().url()).append(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="comment">//Headers</span></span><br><span class="line">            Headers var1 = response.headers();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = var1.size(); i &lt; count; i++) &#123;</span><br><span class="line">                String name = var1.name(i);</span><br><span class="line">                <span class="comment">// Skip headers from the request body as they are explicitly logged above.</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"Content-Type"</span>.equalsIgnoreCase(name) &amp;&amp; !<span class="string">"Content-Length"</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">                    var0.append(name + <span class="string">": "</span> + var1.value(i)).append(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//response.body().string()</span></span><br><span class="line">            <span class="comment">//重点注意:这里有个坑，okhttp中response.body().string()只能有效调用一次，当调用之后，response中的流会被关闭，</span></span><br><span class="line">            <span class="comment">//从而出现异常：java.lang.IllegalStateException: closed</span></span><br><span class="line">            <span class="comment">//buffer.append("body : "+response.body().string()).append("\n");</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//response body</span></span><br><span class="line">            ResponseBody var2 = response.body();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != var2) &#123;</span><br><span class="line">                BufferedSource source = var2.source();</span><br><span class="line">                source.request(Long.MAX_VALUE);</span><br><span class="line">                Buffer var3 = source.buffer();</span><br><span class="line">                Charset var4 = Charset.forName(<span class="string">"UTF8"</span>);</span><br><span class="line">                MediaType contentType = var2.contentType();</span><br><span class="line">                <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var4 = contentType.charset(Charset.forName(<span class="string">"UTF8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(isPlaintext(var3) &amp;&amp; var2.contentLength() != <span class="number">0L</span>)&#123;</span><br><span class="line">                    String var5 = var3.clone().readString(var4);</span><br><span class="line">                    var0.append(var5).append(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            var0.append(<span class="string">"Response-End"</span>);</span><br><span class="line">            Log.i(<span class="string">"Logging"</span>, var0.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPlaintext</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Buffer e = <span class="keyword">new</span> Buffer();</span><br><span class="line">            <span class="keyword">long</span> byteCount = buffer.size() &lt; <span class="number">64L</span>?buffer.size():<span class="number">64L</span>;</span><br><span class="line">            buffer.copyTo(e, <span class="number">0L</span>, byteCount);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span> &amp;&amp; !e.exhausted(); ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> codePoint = e.readUtf8CodePoint();</span><br><span class="line">                <span class="keyword">if</span>(Character.isISOControl(codePoint) &amp;&amp; !Character.isWhitespace(codePoint)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException var6) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>最终输出日志如下，这个都是按照我们自己所设定的输出的日志</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Response-Start : url : https://api.sdk.mobilega.com/v1/wdgame/auth/</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 02 Aug 2017 03:17:02 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Set-Cookie: NSC_KJFMBO-TEL-XFC-TTM=ffffffff091c2fdc45525d5f4f58455e445a4a423660;expires=Wed, 02-Aug-2017 03:18:54 GMT;path=/;secure;httponly</span><br><span class="line">&#123;&quot;token&quot;:&quot;490054868|***|1501643822|24|1|fff88b5e7a10d6845fc593e9266fb3b8&quot;.......&#125;</span><br><span class="line">Response-End</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-3-缓存拦截器"><a href="#3-3-缓存拦截器" class="headerlink" title="3.3 缓存拦截器"></a>3.3 缓存拦截器</h4><p> <strong>1. 简要说明<code>Cache-control</code></strong><br><code>Cache-control</code> 是由服务器返回的 Response 中添加的头信息，它的目的是告诉客户端是要从本地读取缓存还是直接从服务器摘取消息，它有不同的值，每一个值有不同的作用。</p><ul><li><p><strong>public (仅为响应标头)</strong>    </p><blockquote><p>响应：告知任何途径的缓存者,可以无条件的缓存该响应。</p></blockquote></li><li><p><strong>private (仅为响应标头)</strong>    </p><blockquote><p>响应：告知缓存者(一般是指用户代理、常见浏览器的本地缓存；用户也是指系统用户。但也许不应排除某些网关可以识别每个终端用户的情况)，只针对单个用户缓存响应， 且可以具体指定某个字段，如<code>private—&quot;username&quot;</code>，则响应头中名为username的标头内容，不会被共享缓存。</p></blockquote></li><li><p><strong>no-cache</strong></p><blockquote><p>请求：告知缓存者必须原原本本的转发原始请求，并告知任何缓存者别直接拿你缓存的副本糊弄人，你需要去转发我的请求，并验证你的缓存(如果有的话)。<br>对应名词：端对端重载</p><p>响应：允许缓存者缓存副本，那么其实际价值是：总是强制缓存者校验缓存的新鲜度，一旦确认新鲜，则可以使用缓存副本作为响应。 no-cache还可以指定某个包含字段，比如一个典型应用：<code>no-cache=Set-Cookie</code>。 这样做的结果：就是告知缓存者对于<code>Set-Cookie</code>字段，你不要使用缓存内容，而是使用新的，其他内容则可以使用缓存。</p></blockquote></li><li><p><strong>no-store</strong></p><blockquote><p>请求：告知请求和响应都禁止被缓存。(也许是出于隐私考虑)    </p><p>响应：同上</p></blockquote></li><li><p><strong>max-age</strong></p><blockquote><p>请求：强制响应缓存者，根据该值校验新鲜性，即自身的Age值与请求时间做比较，如果超出<code>max-age</code>值则强制去服务器端验证，以确保返回一个新鲜的响应，其功能本质上与传统的Expires类似，但区别在于Expires是根据某个特定日期值做比较，一但缓存者自身的时间不准确，则结果可能就是错误的，而<code>max-age</code>显然无此问题，<code>max-age</code>的优先级也是高于Expires的。    </p><p>响应：同上类似，只不过发出方不一样</p></blockquote></li><li><p><strong>max-stale</strong></p><blockquote><p>请求：意思是允许缓存者发送一个过期不超过指定秒数的、陈旧的缓存。</p><p>响应：同上</p></blockquote></li><li><p><strong>must-revalidate (仅为响应标头)</strong>    </p><blockquote><p>响应：意思是如果缓存过了新鲜期，则必须重新验证，而不是试图返回一个不在新鲜期的缓存。<br>与<code>no-cache</code>的区别在于：no-cache完全无视新鲜期的概念，总是强制重新验证，理论上<code>must-revalidate</code>更节省流量，但相比no-cache可能并不总是那么精准，因为即使缓存者认为是新鲜的，也不能保证服务器端没有做过更新。如果缓存者是一个缓存代理服务器，如果其试图重新验证时，无法连接上原始服务器，则也不允许返回一个不新鲜的、缓存中的副本，而是必须返回一个504 Gateway timeout。</p></blockquote></li><li><p><strong>proxy-revalidate (仅为响应标头)</strong>    </p><blockquote><p>响应：限制上与<code>must-revalidate</code>类似；<br>区别在于受体的范围：proxy-revalidate是要排除掉用户代理的缓存的，即其规则并不应用于用户代理的本地缓存上。</p></blockquote></li><li><p><strong>min-fresh (仅为请求标头)</strong>    </p><blockquote><p>请求：告知缓存者如果当前时间加上min-fresh的值，超了该缓存的过期时间则要给一个新的。</p></blockquote></li><li><p><strong>only-if-cached (仅为请求标头)</strong>    </p><blockquote><p>请求：告知缓存者希望内容来自缓存，且并不关心被缓存响,是否是新鲜的。</p></blockquote></li><li><p><strong>s-maxage (仅为响应标头)</strong>    </p><blockquote><p>响应：与max-age的唯一区别是：s-maxage仅仅应用于共享缓存，而不应用于用户代理的本地缓存、针对单用户的缓存，另外s-maxage的优先级要高于max-age。</p></blockquote></li><li><p><strong>cache-extension</strong> </p><blockquote><p>cache-extension是一个泛化的代称，它指所有自定义或者说扩展的指令，客户端和服务器端都可以自定义扩展Cache-Control相关的指令。<br>实际上我们可以这样设置： <code>Cache-Control:max-age=300, custom-directive = xxx, public</code>， 这样我们就定义了一个被统称为cache-extension的扩展指令，该指令如果对应的客户端或服务器端不认识就会忽略掉。</p></blockquote></li></ul><hr><p><strong>2. 实现缓存拦截器</strong></p><ul><li><p><strong>2.1 缓存拦截器的实现大致可以分为以下几步：</strong></p><ul><li><strong>设置缓存路径以及大小</strong></li><li><strong>创建 OKhttpClient，并添加拦截器</strong></li><li><strong>创建retrofit，并添加client</strong></li></ul></li><li><p><strong>2.2 定义缓存拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. request拦截：如果没有网络就从缓存中获取</span></span><br><span class="line"><span class="comment"> * 2. response拦截：如果有网络就从网络获取，并设置缓存超时时间；</span></span><br><span class="line"><span class="comment"> *                  如果没有网络就设置缓存时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span>  <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//request - 没有网络</span></span><br><span class="line">        Request request  = chain.request();</span><br><span class="line">        <span class="keyword">if</span>(!NetUtils.hasNetwork())&#123;</span><br><span class="line">            request = request.newBuilder()</span><br><span class="line">                    .cacheControl(CacheControl.FORCE_CACHE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//response - 有网络</span></span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">        <span class="keyword">if</span>(NetUtils.hasNetwork())&#123;</span><br><span class="line">            <span class="comment">//设置缓存超时时间为1小时</span></span><br><span class="line">            <span class="keyword">int</span> maxAge = <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">            <span class="comment">//从请求头获取缓存设置</span></span><br><span class="line">            <span class="comment">//String cacheControl = request.cacheControl().toString();</span></span><br><span class="line">            <span class="keyword">return</span>  response.newBuilder()</span><br><span class="line">                    .header(<span class="string">"Cache-Control"</span>,<span class="string">"public,max-age="</span>+maxAge)</span><br><span class="line">                    <span class="comment">//.header("Cache-control",cacheControl)</span></span><br><span class="line">                    .removeHeader(<span class="string">"Pragma"</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//设置超时时间为1天</span></span><br><span class="line">            <span class="keyword">int</span> maxStale = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">            <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                    .header(<span class="string">"Cache-Control"</span>,<span class="string">"public,only-if-cached,max-stale="</span>+maxStale)</span><br><span class="line">                    .removeHeader(<span class="string">"Pragma"</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有代码逻辑，只作为演示</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">NetUtils</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNetwork</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>2.3 定义实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以在接口中增加请求头，设置缓存相关</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Headers</span>(<span class="string">"Cache-Control:public,max-age=3600"</span>)</span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">queryData</span><span class="params">(@Field(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>2.4 简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置缓存路径</span></span><br><span class="line">File cacheFile = <span class="keyword">new</span> File(<span class="keyword">this</span>.getCacheDir(),<span class="string">"cacheFile"</span>);</span><br><span class="line"><span class="comment">//设置缓存为10M</span></span><br><span class="line">Cache cache = <span class="keyword">new</span> Cache(cacheFile,<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建OKHttpClient，添加拦截器</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .addNetworkInterceptor(<span class="keyword">new</span> CacheInterceptor())  </span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建retrofit</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">""</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create(<span class="keyword">new</span> Gson()))</span><br><span class="line">        .client(client)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求接口</span></span><br><span class="line">ApiService apiService = retrofit.create(ApiService.class);</span><br><span class="line">apiService.queryData(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>3. 参考文章</strong><br><a href="http://www.cnblogs.com/_franky/archive/2011/11/23/2260109.html" target="_blank" rel="noopener">1. Web缓存相关知识点</a><br><a href="http://blog.csdn.net/u010286855/article/details/52608485" target="_blank" rel="noopener">2. Retrofit2,okhttp3 通过拦截器（Interceptor）两种缓存（离线和在线）</a><br><a href="https://caster.io/episodes/retrofit-2-offline-cache/" target="_blank" rel="noopener">3. Retrofit 2: Enabling Offline Cache</a></p><hr><h4 id="3-4-拦截器中统一添加请求头"><a href="#3-4-拦截器中统一添加请求头" class="headerlink" title="3.4 拦截器中统一添加请求头"></a>3.4 拦截器中统一添加请求头</h4><p><strong>在请求接口时都会添加请求头信息，对于公共的请求头我们可以统一添加，不要重复造轮子，但是也要结合实际，因为并不是所有的请求头信息都会是相同的，这时候我们便可以在接口定义时增加特殊的请求头信息。</strong></p><ul><li><p><strong>统一添加公共请求头</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//添加统一的请求头，注意不要盲目照搬，</span></span><br><span class="line">       <span class="comment">//这里添加的header与在接口中传入的header即使同名，也不会覆盖，而是并行存在。</span></span><br><span class="line">       Request request = chain.request().newBuilder()</span><br><span class="line">               .addHeader(<span class="string">"Client-Info"</span>,<span class="string">"Android/7.0"</span>)</span><br><span class="line">               .addHeader(<span class="string">"Game_ID"</span>,<span class="string">"5015"</span>)</span><br><span class="line">               .addHeader(<span class="string">"Accpet"</span>,<span class="string">"application/json"</span>)</span><br><span class="line">               .build();</span><br><span class="line">       <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果有个接口需要单独增加一个头信息，如：auth，可以在接口定义时传入或者在接口调用时传入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//需要特别增加的都可以依次加入，选择哪个方式都可以</span></span><br><span class="line">   <span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@Headers</span>(<span class="string">"auth:URGLDSUWPWEWP"</span>)</span><br><span class="line">   <span class="meta">@POST</span></span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">request18</span><span class="params">(@Field(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@POST</span></span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">request18</span><span class="params">(@Header(<span class="string">"auth"</span>)</span> String auth,@FieldMap Map&lt;String,String&gt; map)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@POST</span></span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">request18</span><span class="params">(@HeaderMap Map&lt;String,String&gt; headerMap,@FieldMap Map&lt;String,String&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>不同的方式加入的请求头并不会覆盖，即使是同名的。不过需要注意的是：同名参数具体解析谁需要服务端决定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--&gt; POST https:<span class="comment">//api.sdk.game.com/v1/ztgame/login http/1.1</span></span><br><span class="line"><span class="comment">//统一添加的请求头</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.542</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Content-Type: application/x-www-form-urlencoded</span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Content-Length: <span class="number">38</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: GAME-ID: <span class="number">5012</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Accept: application/json</span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Client-Info: ***</span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Authentication: ****</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器添加的请求头</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Client-Info: Android/<span class="number">7.0</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: GAME-ID: <span class="number">5015</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: Accpet: application/json</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口定义单独传入的请求头</span></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.543</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: auth: YUYUYU</span><br><span class="line"></span><br><span class="line"><span class="number">08</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">06.544</span> <span class="number">27587</span>-<span class="number">28341</span>/? D/OkHttp: --&gt; <span class="function">END <span class="title">POST</span> <span class="params">(<span class="number">38</span>-<span class="keyword">byte</span> body)</span></span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h4><p><a href="https://futurestud.io/tutorials/android-basic-authentication-with-retrofit" target="_blank" rel="noopener">1. Retrofit — Basic Authentication on Android</a></p>]]></content>
      
      
      <categories>
          
          <category> Retrofit2.0系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit2.0系列 - (1)玩转注解</title>
      <link href="/2019/10/30/Retrofit2.0%E7%B3%BB%E5%88%97%20-%20(1)%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/10/30/Retrofit2.0%E7%B3%BB%E5%88%97%20-%20(1)%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/Retrofit2.0%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3/">Retrofit 2.0系列 - (1)玩转注解</a><br><a href="https://www.syncxiao.com/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AA%E5%99%A8/">Retrofit 2.0系列 - (2)全面解析拦截器</a><br><a href="https://www.syncxiao.com/2019/10/30/Retrofit2-0%E7%B3%BB%E5%88%97-&#40;3&#41;%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82/">Retrofit2.0系列 - (3)简单封装请求</a></p><hr><h4 id="1-方法注解："><a href="#1-方法注解：" class="headerlink" title="1. 方法注解："></a>1. 方法注解：</h4><p><strong>Retrofit 2.0 支持以下方法注解：<code>@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP</code>，这和Http中涉及到的请求方法基本保持一致，但是多了一个：<code>@HTTP</code>的方法注解。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义HTTP请求方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@HTTP</span> ： 方法注解，可以替代HTTP中其他的方法</span></span><br><span class="line"><span class="comment">    * method ：指定请求的方法，如GET、POST</span></span><br><span class="line"><span class="comment">    * path ： 接口路径</span></span><br><span class="line"><span class="comment">    * hasBody ： 是否有请求体</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@HTTP</span>(method = <span class="string">"GET"</span>,path = <span class="string">"wdgame/auth/&#123;id&#125;"</span>,hasBody = <span class="keyword">false</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn17</span><span class="params">(@Path(<span class="string">"id"</span>)</span>String id)</span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="2-标记注解："><a href="#2-标记注解：" class="headerlink" title="2. 标记注解："></a>2. 标记注解：</h4><ul><li><p><strong><code>@FormUrlEncoded</code>：用于<code>POST</code>请求时以表单方式提交</strong></p></li><li><p><strong><code>@Multipart</code>:用于文件上传</strong></p></li><li><p><strong><code>@Streaming</code>:用于大文件的下载</strong></p></li></ul><h4 id="3-参数注解："><a href="#3-参数注解：" class="headerlink" title="3. 参数注解："></a>3. 参数注解：</h4><p> <strong>以下请求链接中BASE_URL为：<a href="https://api.sdk.com/v2/" target="_blank" rel="noopener">https://api.sdk.com/v2/</a></strong></p><ul><li><strong><code>@Path</code>：URL占位符，用于请求链接的?号之前，可支持多个@Path连续使用，但是参数个数固定</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/&#123;auth&#125;?name=wd</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * https://api.sdk.com/v2/wdgame/UEGLAUWGJAJG?name=wd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/&#123;auth&#125;"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn1</span><span class="params">(@Path(<span class="string">"auth"</span>)</span> String auth)</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/&#123;auth&#125;/&#123;id&#125;</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * https://api.sdk.com/v2/wdgame/IDFAJGADKHGA/642232884</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/&#123;auth&#125;/&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn2</span><span class="params">(@Path(<span class="string">"auth"</span>)</span> String auth, @<span class="title">Path</span><span class="params">(<span class="string">"id"</span>)</span> String id)</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>@Query &amp; @QueryMap</code>：用于请求链接的?号之后，可支持多个@Query连续使用，但是参数个数固定，@QueryMap参数不固定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/auth/?authId=??&amp;id=??</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * https://api.sdk.com/v2/wdgame/auth/?authId=YWKFIADHGFAL&amp;id=623042744</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn3</span><span class="params">(@Query(<span class="string">"authId"</span>)</span> String authId, @<span class="title">Query</span><span class="params">(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/auth/?authId=??&amp;id=??</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * https://api.sdk.com/v2/wdgame/auth/?authId=YWKFIADHGFAL&amp;id=623042744</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 参数以Map的形式传入</span></span><br><span class="line"><span class="comment">    * map.put("authId","QWEDOWUEHGSL")</span></span><br><span class="line"><span class="comment">    * map.put("id","232372794")</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn4</span><span class="params">(@QueryMap Map&lt;String, String&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>@Field &amp; @FieldMap</code>：配合<code>@FormUrlEncoded</code>使用，用于POST请求时简单的键值对参数的传递，支持Map形式传递参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/auth</span></span><br><span class="line"><span class="comment">    * 表单形式提交</span></span><br><span class="line"><span class="comment">    * 参数：account、password</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn5</span><span class="params">(@Field(<span class="string">"account"</span>)</span> String account, @<span class="title">Field</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/auth</span></span><br><span class="line"><span class="comment">    * 表单形式提交</span></span><br><span class="line"><span class="comment">    * 参数：account、password</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 参数以Map的形式传入</span></span><br><span class="line"><span class="comment">    * map.put("account","wd")</span></span><br><span class="line"><span class="comment">    * map.put("password","123456")</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn6</span><span class="params">(@FieldMap Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/auth</span></span><br><span class="line"><span class="comment">    * 传递数组参数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 网上说可以这样传递，但是多个数组会有问题，暂未考证</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn8</span><span class="params">(@Field(<span class="string">"account[]"</span>)</span> String... account)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>@Body</code>：将实例对象转化为json格式数据传递，可以不需要配合<code>@FormUrlEncoded</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/auth</span></span><br><span class="line"><span class="comment">    * 以对象的形式传递json数据</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * AccountBean.Account bean = new AccountBean.Account();</span></span><br><span class="line"><span class="comment">    * bean.setAccount("wd");</span></span><br><span class="line"><span class="comment">    * bean.setUid(1246);</span></span><br><span class="line"><span class="comment">    * requestIn7(bean)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn7</span><span class="params">(@Body AccountBean.Account bean)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>@Part &amp; @PartMap &amp; @Multipart</code>：用于POST文件上传，需要配合<code>@Multipart</code>使用，多用于字节流的传输</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单文件上传</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/upload</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 未验证</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Multipart</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"wdgame/upload"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn9</span><span class="params">(@Part(<span class="string">"desc"</span>)</span> ResponseBody desc ,@Part MultipartBody.Part file)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 多文件上传</span></span><br><span class="line"><span class="comment">    * 访问链接：https://api.sdk.com/v2/wdgame/upload</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 未验证</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Multipart</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"wdgame/upload"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn10</span><span class="params">(@Part(<span class="string">"desc"</span>)</span> ResponseBody desc ,@PartMap Map&lt;String,ResponseBody&gt; files)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>@Header &amp; @Headers</code>:请求头的单独设置或以参数的形式传入，适合于特殊情况，不使用统一的请求头，一个是修饰参数、一个是修饰方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 动态设置单个请求头</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn11</span><span class="params">(@Header(<span class="string">"X-Client-Info"</span>)</span>String info,@<span class="title">Query</span><span class="params">(<span class="string">"authId"</span>)</span> String authId, @<span class="title">Query</span><span class="params">(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 动态设置多个请求头</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn12</span><span class="params">(@HeaderMap Map&lt;String,String&gt; map,@Query(<span class="string">"authId"</span>)</span> String authId, @<span class="title">Query</span><span class="params">(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 静态设置多个请求头</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Headers</span>(&#123;<span class="string">"X-Client-Info:******"</span>,<span class="string">"Accept:******"</span>&#125;)</span><br><span class="line">   <span class="meta">@GET</span>(<span class="string">"wdgame/auth"</span>)</span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn13</span><span class="params">(@Query(<span class="string">"authId"</span>)</span> String authId, @<span class="title">Query</span><span class="params">(<span class="string">"id"</span>)</span> String id)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>@Url</code>：Url以参数的形式传入，用于特殊的需要单独构造的Url，并且参数、请求头也都可以单独传递</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求链接、参数、请求头全部分散传入</span></span><br><span class="line"><span class="comment">    * https://api.sdk.com/v2/wdgame/auth?auth=DGSDJLWOURNGA</span></span><br><span class="line"><span class="comment">    * 如果参数在？之前，此种形式存在问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GET</span></span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn14</span><span class="params">(@Url String url, @QueryMap Map&lt;String, Object&gt; paramMap, @HeaderMap Map&lt;String, Object&gt; headsMap)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求链接、参数、请求头全部分散传入</span></span><br><span class="line"><span class="comment">    * https://api.sdk.com/v2/wdgame/auth</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@POST</span></span><br><span class="line">   <span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn15</span><span class="params">(@Url String url, @FieldMap Map&lt;String, Object&gt; paramMap, @HeaderMap Map&lt;String, Object&gt; headsMap)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>@Streaming</code>：用于大文件的下载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于下载大文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Streaming</span></span><br><span class="line">   <span class="meta">@GET</span></span><br><span class="line">   <span class="function">Call&lt;ResponseBody&gt; <span class="title">requestIn16</span><span class="params">(@Url String url)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Retrofit2.0系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJava系列 - (7)Obervables之间的区别</title>
      <link href="/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20(7)Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20(7)Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><h3 id="1-被观察者之间之间的区别"><a href="#1-被观察者之间之间的区别" class="headerlink" title="1. 被观察者之间之间的区别"></a>1. 被观察者之间之间的区别</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Observable&lt;泛型&gt;</td><td style="text-align:left">能发送0个或n个onNext事件，最终以onComplete或onError终止事件。</td></tr><tr><td style="text-align:center">Flowable&lt;泛型&gt;</td><td style="text-align:left">能发送0个或n个onNext事件，最终以onComplete或onError事件终止，并且支持背压，可以控制数据源发送的速度。</td></tr><tr><td style="text-align:center">Single&lt;泛型&gt;</td><td style="text-align:left">只能发送单个onSuccess或onError事件同时终止事件。</td></tr><tr><td style="text-align:center">Maybe&lt;泛型&gt;</td><td style="text-align:left">能发送0个或1个数据，要么是onSuccess，要么是onError，同时终止事件，不会同时执行onComplete。</td></tr><tr><td style="text-align:center">Completable</td><td style="text-align:left">从来不发送数据，只处理onError或onComplete事件同时终止事件，不会同时执行onError和onComplete。</td></tr></tbody></table><a id="more"></a><p><strong>1. Observable&lt;泛型&gt;</strong></p><blockquote><ol><li>可以发送0或n个数据，只要发送了onComplete或onError事件，就会停止发送数据。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="string">"A"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"B"</span>);</span><br><span class="line">        <span class="comment">//发送异常不会导致奔溃，下游会在onError中收到异常消息</span></span><br><span class="line">        emitter.onError(<span class="keyword">new</span> Throwable(<span class="string">"Error"</span>));</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxObservable onNext ： "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxObservable onError ： "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxObservable onComplete ： "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>2. Flowable&lt;泛型&gt;</strong></p><blockquote><ol><li>可以发送0或n个数据，只要发送了onComplete或onError事件，就会停止发送数据。</li><li>可以在观察者的onSubscribe方法中通过<code>Subscription.request(n)</code>来设置请求发送事件的数量。</li><li>可以通过使用背压(BackpressureStrategy)来解决上游发送事件的速度和下游处理事件的速度不同导致的问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="string">"A"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"B"</span>);</span><br><span class="line">        <span class="comment">//发送异常不会导致奔溃，下游会在onError中收到异常消息</span></span><br><span class="line">        emitter.onError(<span class="keyword">new</span> Throwable(<span class="string">"Error"</span>));</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.BUFFER)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> FlowableSubscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//设置请求发送事件的数量</span></span><br><span class="line">                s.request(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"rxFlowable onNext ： "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"rxFlowable onError ： "</span>+t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"rxFlowable onComplete ： "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>3. Single&lt;泛型&gt;</strong></p><blockquote><ol><li><p>只能发送通过onSuccess或onError发送单个事件，即使有多个事件，也只会发送第一个，并且发送之后订阅终止。</p></li><li><p>onSuccess和onError不能同时发送时，否则会出现如下异常，导致程序奔溃：<code>The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Single.create(<span class="keyword">new</span> SingleOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(SingleEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//下游之后收到第一个onSuccess发送的数据</span></span><br><span class="line">        emitter.onSuccess(<span class="string">"Success"</span>);</span><br><span class="line">        emitter.onSuccess(<span class="string">"Success2"</span>);</span><br><span class="line">        <span class="comment">//emitter.onError(new Throwable("Error"));</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> SingleObserver&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxSingle onSuccess ： "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxSingle onError ： "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>4. Maybe&lt;泛型&gt;</strong></p><blockquote><ol><li><p>通过onSuccess发送多个事件时，下游只会收到第一个事件，后面的事件全部被抛弃，并且不会同时发送onComplete事件。</p></li><li><p>onSuccess和onError不能同时发送时，否则会出现如下异常，导致程序奔溃：<code>The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Maybe.create(<span class="keyword">new</span> MaybeOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(MaybeEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onSuccess(<span class="string">"Success"</span>);</span><br><span class="line">        emitter.onSuccess(<span class="string">"Success2"</span>);</span><br><span class="line"><span class="comment">//emitter.onError(new Throwable("Error"));</span></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> MaybeObserver&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxMaybe onSuccess ： "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxMaybe onError ： "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxMaybe onComplete ： "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>5. Completable</strong></p><blockquote><ol><li>只能处理onError或者onComplete发送的事件，并且不会同时发送，一个事件发送之后，订阅关系终止。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Completable.create(<span class="keyword">new</span> CompletableOnSubscribe() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CompletableEmitter emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onError(<span class="keyword">new</span> Throwable(<span class="string">"Error"</span>));</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> CompletableObserver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxCompletable onComplete ： "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"rxCompletable onError ： "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><h3 id="2-观察者之间的区别"><a href="#2-观察者之间的区别" class="headerlink" title="2. 观察者之间的区别"></a>2. 观察者之间的区别</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:center">Observer&lt;泛型&gt;</td><td style="text-align:left">onSubscribe(Disposable d)、onNext(T t)、onError(Throwable e)、onComplete()</td></tr><tr><td style="text-align:center">FlowableSubscriber&lt;泛型&gt;</td><td style="text-align:left">onSubscribe(Subscription s)、onNext(T t)、onError(Throwable e)、onComplete()，继承自Subscriber</td></tr><tr><td style="text-align:center">SingleObserver&lt;泛型&gt;</td><td style="text-align:left">onSubscribe(Disposable d)、onSuccess(T t)、onError(Throwable e)</td></tr><tr><td style="text-align:center">MaybeObserver&lt;泛型&gt;</td><td style="text-align:left">onSubscribe(Disposable d)、onSuccess(T t)、onError(Throwable e)、onComplete()</td></tr><tr><td style="text-align:center">CompletableObserver</td><td style="text-align:left">onSubscribe(Disposable d)、onError(Throwable e)、onComplete()</td></tr></tbody></table><h4 id="1-方法说明"><a href="#1-方法说明" class="headerlink" title="1. 方法说明"></a>1. 方法说明</h4><p><strong>1. onSubscribe(Disposable d)、 onSubscribe(Subscription s)</strong></p><blockquote><p>观察者和被观察者建立订阅关系时会最先调用该方法。</p><p><strong>Disposable.dispose()：</strong>表示主动断开上下游的订阅关系。<br><strong>Disposable.isDisposed()：</strong>判断当前上下游之间的订阅关系是否已经断开。</p><p><strong>Subscription .request(Long.MAX_VALUE)：</strong>设置观察者能处理事件的数量，如果设置为0，下游将收不到任何onNext事件，即使上游发送了很多。<br><strong>Subscription .cancel()：</strong>表示主动断开上下游的订阅关系。</p></blockquote><p><strong>2. onNext(T t)、onSuccess(T t)、onError(Throwable e)</strong></p><blockquote><p>处理上游对应onNext、onSuccess、onError事件发送的结果。</p></blockquote><hr><h3 id="3-发射器Emitter之间的区别"><a href="#3-发射器Emitter之间的区别" class="headerlink" title="3. 发射器Emitter之间的区别"></a>3. 发射器Emitter之间的区别</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">继承</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:center">Emitter</td><td style="text-align:center">父类</td><td style="text-align:left">onNext(T t)、onError(Throwable e)、onComplete()</td></tr><tr><td style="text-align:center">ObservableEmitter&lt;泛型&gt;</td><td style="text-align:center">是</td><td style="text-align:left">setDisposable(Disposable d)、setCancellable(Cancellable c)、isDisposed()、tryOnError(Throwable t)</td></tr><tr><td style="text-align:center">FlowableEmitter&lt;泛型&gt;</td><td style="text-align:center">是</td><td style="text-align:left">setDisposable(Disposable d)、setCancellable(Cancellable c)、isCancelled()、tryOnError(Throwable t)、long requested()</td></tr><tr><td style="text-align:center">SingleEmitter&lt;泛型&gt;</td><td style="text-align:center">否</td><td style="text-align:left">setDisposable(Disposable d)、setCancellable(Cancellable c)、isDisposed()、tryOnError(Throwable t)、 onSuccess(T t)、onError(Throwable t)</td></tr><tr><td style="text-align:center">MaybeEmitter&lt;泛型&gt;</td><td style="text-align:center">否</td><td style="text-align:left">setDisposable(Disposable d)、setCancellable(Cancellable c)、isDisposed()、tryOnError(Throwable t)、 onSuccess(T t)、onError(Throwable t)、onComplete()</td></tr><tr><td style="text-align:center">CompletableEmitter</td><td style="text-align:center">否</td><td style="text-align:left">setDisposable(Disposable d)、setCancellable(Cancellable c)、isDisposed()、tryOnError(Throwable t)、onError(Throwable t)、onComplete()</td></tr></tbody></table><h4 id="1-方法说明-1"><a href="#1-方法说明-1" class="headerlink" title="1. 方法说明"></a>1. 方法说明</h4><p><strong>1. Emitter的onNext(T t)、onError(Throwable e)、onComplete()</strong></p><blockquote><p>ObservableEmitter和FlowableEmitter都是继承自Emitter，通过以上方法进行数据的发送。</p></blockquote><p><strong>2. isDisposed()、isCancelled()</strong></p><blockquote><p>都是用于判断当前上下游之间是否已经取消订阅关系，isCancelle()是FlowableEmitter独有的。</p></blockquote><p><strong>3. FlowableEmitter 的 long requested()</strong></p><blockquote><p>用于获取下游设置的事件处理数量。</p><p><strong>注意：</strong><br><strong>1. 如果异步订阅，即上下游不在同一个线程，上游emitter.requested()获取数量默认是128(RxJava内部设置的默认值就是128)，并不是下游Subscription.request(n)设置的数量。</strong></p><p><strong>2. 如果是同步订阅，上游获取的emitter.requested()等于下游Subscription.request(n)设置的数量，并且上游每发送一个事件、下游接收到一个事件，emitter.requested()获取的数据都会同步更新。</strong></p></blockquote><hr><h3 id="4-背压-BackpressureStrategy-策略之间的区别"><a href="#4-背压-BackpressureStrategy-策略之间的区别" class="headerlink" title="4. 背压(BackpressureStrategy)策略之间的区别"></a>4. 背压(BackpressureStrategy)策略之间的区别</h3><blockquote><p><strong>背压是基于异步线程的。</strong></p></blockquote><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">MISSING</td><td style="text-align:left">相当于没有使用背压策略。当上游发送事件数量大于缓存区大小时(默认128)，将会提示异常并在下游onError事件中接收到异常提醒：io.reactivex.exceptions.MissingBackpressureException: Queue is full?!可以在后面继续使用类似于onBackpressureBuffer()、onBackpressureLatest()、onBackpressureDrop()的策略。</td></tr><tr><td style="text-align:left">ERROR</td><td style="text-align:left">当上游发送事件数量大于缓存区大小时(默认128)，将会抛出异常并在下游onError事件中接收到异常：io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</td></tr><tr><td style="text-align:left">BUFFER</td><td style="text-align:left">相当于将缓存区设置为无限大，不管上游发送多少数据都不会抛出异常，但是要注意可能会因为事件数量过多导致OOM</td></tr><tr><td style="text-align:left">DROP</td><td style="text-align:left">将超过默认缓存区(128)大小的事件直接抛弃，比如上游发送了160个事件，最终保存的只有1-128,129往后的都被抛弃了。</td></tr><tr><td style="text-align:left">LATEST</td><td style="text-align:left">将超过默认缓存区(128)大小的事件直接抛弃，但是会保存最后一个事件，比如上游发送了160个事件，最终保存的只有1-128 + 160,129-159都被抛弃了。</td></tr></tbody></table><p><strong>1. MISSING - - 相当于没有使用背压策略</strong></p><blockquote><p>比如：上游一起发送了160个事件，下游每次接收70个事件，当上游发送事件数量大于128时，直接抛出<code>io.reactivex.exceptions.MissingBackpressureException: Queue is full?!</code>异常，回调到下游的onError，下游将接收不到前面发送的其他数据。</p><p><strong>输出结果：</strong><br>上游发送事件：0 – 159 共计160个事件，超出缓存区大小，抛出异常。<br><img src="https://i.loli.net/2019/06/08/5cfbcd1fc505d32980.png" alt="miss.png"></p></blockquote><p><strong>2. ERROR</strong></p><blockquote><p>比如：上游一起发送了160个事件，下游每次接收70个事件，当上游发送事件数量大于128时，直接抛出<code>io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</code>异常，回调到下游的onError，下游将接收不到前面发送的其他数据。</p><p><strong>输出结果：</strong><br>上游发送事件：0 – 159 共计160个事件，超出缓存区大小，抛出异常。<br><img src="https://i.loli.net/2019/06/08/5cfbcd68364ef96978.png" alt="err.png"></p></blockquote><p><strong>3. BUFFER - -  onBackpressureBuffer()</strong></p><blockquote><p>比如：上游一起发送了160个事件，下游每次接收70个事件，到第三次接收时，160个事件全部都被下游接收完成。</p><p><strong>输出结果：</strong><br>上游发送事件：0 – 159 共计160个事件，<br>第一次请求70个事件：输出0 – 69，<br>第二次请求70个事件：输出 70 – 139，<br>第二次请求70个事件：输出 140 – 159，onComplete结束订阅关系。<br><img src="https://i.loli.net/2019/06/08/5cfbcd1e4e42472009.png" alt="buffer.png"></p></blockquote><p><strong>4. DROP - - onBackpressureDrop()</strong></p><blockquote><p>比如：上游一起发送了160个事件，下游每次接收70个事件，会发现第二次接收之后总共只有128个事件，即使再次要求接收事件，也不会收到任何数据，这说明上游发送的160个事件中，超过了128的事件都被直接抛弃了。</p><p><strong>输出结果：</strong><br>上游发送事件：0 – 159 共计160个事件，<br>第一次请求70个事件：输出0 – 69，<br>第二次请求70个事件：输出 70 – 127 ， onComplete结束订阅关系。<br><img src="https://i.loli.net/2019/06/08/5cfbcd1eb85e074384.png" alt="drop.png"></p></blockquote><p><strong>5. LATEST - - onBackpressureLatest()</strong></p><blockquote><p>比如：上游一起发送了160个事件，下游每次接收70个事件，会发现第二次接收之后总共只有129个事件，即使再次要求接收事件，也不会收到任何数据，这说明上游发送的160个事件中，第1-128和第160个事件被保留了，其余的129-159之间的事件都被抛弃了。</p><p><strong>输出结果：</strong><br>上游发送事件：0 – 159 共计160个事件，<br>第一次请求70个事件：输出0 – 69，<br>第二次请求70个事件：输出 70 – 127、159共计129个事件， onComplete结束订阅关系。<br><img src="https://i.loli.net/2019/06/08/5cfbcd1f72b5748052.png" alt="latest.png"></p></blockquote><p><strong>6. 示例</strong></p><blockquote><p><strong>上游：</strong>一次性发送160个事件。 <strong>下游：</strong>每次请求70个事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Subscription subscription;</span><br><span class="line"><span class="comment">//点击事件，每次请求发送70个事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">requestRx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    subscription.request(<span class="number">70</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rxFlowable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//上游一次性发送160个事件</span></span><br><span class="line">            <span class="keyword">while</span> (a &lt; <span class="number">160</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游要求事件数量 : "</span> + emitter.requested());</span><br><span class="line">                Log.d(TAG, <span class="string">"上游发送数据 : "</span> + a);</span><br><span class="line">                emitter.onNext(a);</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置不同的背压处理方式</span></span><br><span class="line">    &#125;, BackpressureStrategy.DROP)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> FlowableSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//外部定义Subscription，方便请求事件</span></span><br><span class="line">                    subscription = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer s)</span> </span>&#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"下游rxFlowable onNext ： "</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                    a = <span class="number">0</span>;</span><br><span class="line">                    Log.d(TAG, <span class="string">"下游rxFlowable onError ： "</span> + t.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    a = <span class="number">0</span>;</span><br><span class="line">                    Log.d(TAG, <span class="string">"下游rxFlowable onComplete ： "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h3 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5. 线程调度"></a>5. 线程调度</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Schedulers.io()</td><td style="text-align:left">用于IO密集型操作，比如网络请求、读取SD卡文件、查询数据库等，具有线程缓存机制，在此调度器接收到任务后，先检查线程池中是否有空闲的线程，如果有则复用，如果没有则创建新的线程，并加入到线程池，如果每次都没有空闲的线程，则会无上限的创建线程。</td></tr><tr><td style="text-align:left">Schedulers.computation()</td><td style="text-align:left">用于CPU密集型计算任务，即不会被IO等操作限制性能的耗时操作，比如xml、json文件解析、Bitmap图像压缩等，具有固定的线程池，大小为CPU的核数。不可用于IO操作，因为IO操作的等待时间会浪费CPU。</td></tr><tr><td style="text-align:left">Schedulers.newThread()</td><td style="text-align:left">在每执行一个任务时创建一个新的线程，不具有缓存机制。新创建一个线程比复用一个线程更耗时，虽然使用io()的地方都可以使用newThread()，但是newThread()的效率没有io()高。</td></tr><tr><td style="text-align:left">Schedulers.single()</td><td style="text-align:left">拥有一个线程单例，所有的任务都在这一个线程中执行，如果该线程中有任务在执行，其他任务将会按照FIFO的原则依次执行。</td></tr><tr><td style="text-align:left">Schedulers.trampoline()</td><td style="text-align:left">在当前线程立即执行任务，如果当前线程有正在执行的任务，则将其暂停，直到新插入的任务执行完毕，再继续执行之前未完成的任务。</td></tr><tr><td style="text-align:left">AndroidSchedulers.mainThread()</td><td style="text-align:left">在Android UI线程中执行任务，专为Android开发定制。</td></tr></tbody></table><p><strong>1. 线程切换</strong></p><blockquote><p><strong>subscribeOn(@NonNull Scheduler scheduler)</strong><br>事件产生：指定上游Observable发送数据、订阅时所处的线程，多次调用只有第一次生效。</p><p><strong>observeOn(@NonNull Scheduler scheduler)</strong><br>事件消费：指定下游Observer接受数据时所处的线程，多次调用都会生效，最终以最后一次调用为主。</p></blockquote><p><strong>2. doOnSubscribe(Consumer&lt;? super Subscription&gt; onSubscribe)</strong></p><blockquote><p> doOnSubscribe()与onStart()类似，在subscribe()调用之后，事件发送之前被调用，但是doOnSubscribe()可以指定线程。</p><p> 默认情况下，doOnSubscribe发生在subscribe()所在线程，而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p><p> 多个doOnSubscribe()&amp;subscribeOn()组合在一起同时调用时，越靠后的越先被调用，但是如果是doOnSubscribe()&amp;doOnSubscribe&amp;subscribeOn()的方式调用，则越靠近subscribeOn()的越先调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(onSubscribe)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果订阅开始时需要loading</span></span><br><span class="line">            progressBar.setVisibility(View.VISIBLE); <span class="comment">// 需要在主线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定主线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Observable </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJava系列 - (6)操作符说明</title>
      <link href="/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20(6)%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20(6)%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;1&#41;%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/">RxJava系列 - (1)初步认识</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;2&#41;%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">RxJava系列 - (2)线程控制</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;3&#41;%E5%8F%98%E6%8D%A2%E7%AC%A6%E6%93%8D%E4%BD%9C/">RxJava系列 - (3)变换符操作</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;4&#41;zip%E6%93%8D%E4%BD%9C%E7%AC%A6/">RxJava系列 - (4)zip操作符</a><br><a href="https://www.syncxiao.com/2019/10/30/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;5&#41;Backpressure%20&amp;%20Flowable/">RxJava系列 - (5)Backpressure &amp; Flowable</a><br><a href="https://www.syncxiao.com/2019/04/20/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;6&#41;%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%B4%E6%98%8E/">RxJava系列 - (6)操作符说明</a><br><a href="https://www.syncxiao.com/2019/06/08/RxJava%E7%B3%BB%E5%88%97%20-%20&#40;7&#41;Observables%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">RxJava系列 - (7)Observables之间的区别 </a></p><hr><h3 id="1-创建操作符"><a href="#1-创建操作符" class="headerlink" title="1. 创建操作符"></a>1. 创建操作符</h3><p><strong>1. create(ObservableOnSubscribe<t> source)</t></strong></p><blockquote><p>完整的创建一个Observable或Flowable。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.BUFFER);</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>2. just(T item1, T item2, T item3, T item4, T item5, T item6, T item7)</strong></p><blockquote><p>快速创建一个Observable对象，直接发送事件给下游，最多只能发送10个事件。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>)</span><br></pre></td></tr></table></figure><p><strong>3. fromArray(T… items)</strong></p><blockquote><p>快速创建一个Observable对象，将传入的数据直接发送给下游。</p><p><strong>注意：传入的如果和list集合，最终返回给下游的也是一个list集合，原样传给了下游。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以直接发送</span></span><br><span class="line">Observable.fromArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).subscribe();</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line">Integer[] items = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">Observable.fromArray(items).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"数据 : "</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是list，下游收到的也是list</span></span><br><span class="line">Observable.fromArray(list).subscribe(<span class="keyword">new</span> Consumer&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(List&lt;Integer&gt; integers)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"数据 : "</span>+integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>4. fromIterable(Iterable&lt;? extends T&gt; source)</strong></p><blockquote><p>快速创建一个Observable对象，将传入的list集合数据发送给下游。</p><p><strong>注意：传入的数据只能是Iterable对象的数据，不能直接传入数组或者数字。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromIterable(list).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"数据 : "</span>+integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>5. empty()、error(final Throwable exception) 、never()</strong></p><blockquote><p><strong>1. empty()：</strong> 该方法创建的被观察者对象发送事件的特点：仅发送Complete事件，直接通知完成， 即观察者接收后会直接调用onCompleted。<br><strong>Observable observable1=Observable.empty();</strong> </p><p><strong>2. error()：</strong> 该方法创建的被观察者对象发送事件的特点：仅发送Error事件，直接通知异常(可以自定义异常)，即观察者接收后会直接调用onError。<br><strong>Observable observable2=Observable.error(new RuntimeException())</strong></p><p><strong>3. never()：</strong>该方法创建的被观察者对象发送事件的特点：不发送任何事件，即观察者接收后什么都不调用。<br><strong>Observable observable3=Observable.never();</strong></p></blockquote><p><strong>6. defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</strong></p><blockquote><p>延迟创建Observable，即直到有观察者订阅时才动态创建一个新的Observable，并发送最新的数据。</p><p>比如：需要定时执行或周期性执行某些操作，还要确保数据的最新的，就可以使用defer。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如已经定义变量a</span></span><br><span class="line">Observable observable = Observable.defer(<span class="keyword">new</span> Callable&lt;ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> ObservableSource&lt;?&gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="keyword">return</span> Observable.just(a);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="comment">//然后变量a被重新赋值</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"数据 : "</span>+o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：10</span></span><br></pre></td></tr></table></figure><p><strong>7. timer(long delay, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>创建一个Observable对象，并在指定的延迟时间之后发送一个数值0(Long类型)给下游，本质上就是：延迟指定时间后调用onNext(0)。</p><p>//参数delay表示延迟时间，参数unit表示时间单位<br><strong>timer(long delay, TimeUnit unit)</strong><br>//参数scheduler表示线程调度<br><strong>timer(long delay, TimeUnit unit, Scheduler scheduler)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(<span class="number">3</span>,TimeUnit.SECONDS)</span><br><span class="line">   .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">           Log.d(TAG,<span class="string">"onNext 收到数据 ： "</span>+aLong);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Log.d(TAG,<span class="string">"onComplete------"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：onNext中收到数据0，然后onComplete被回调。</span></span><br></pre></td></tr></table></figure><p><strong>8. interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>创建一个Observable对象，每隔指定的时间发送一个事件，事件序列由0开始，每次递增1，无限递增。</p><p>//参数initialDelay表示初次发送事件的延时时间，参数period表示之后发送事件的间隔时间，参数unit表示时间单位，schedule表示线程调度<br><strong>interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">5</span>, <span class="number">1</span>, TimeUnit.SECONDS, Schedulers.io())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"下游收到数据 : "</span>+aLong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：0 1 2 3....,第一次输出0时延迟了5s，以后每隔1s产生一个事件。</span></span><br></pre></td></tr></table></figure><p><strong>9. intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>创建一个Observable，每隔指定的时间，从指定位置开始，发送指定数量的事件，每次递增1。</p><p>//参数start：事件发送开始的位置<br>//参数count：发送事件的总数<br>//参数initialDelay：初次发送事件的延迟时间<br>//参数period：后续发送事件的间隔时间<br><strong>intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从2开始，总计发送10个事件，首次延迟2s，之后间隔1s发送一个事件</span></span><br><span class="line">Observable.intervalRange(<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"下游收到数据 : "</span>+aLong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：2 3 4 ....  11，从2开始总共发送10个事件</span></span><br></pre></td></tr></table></figure><p><strong>10. range(final int start, final int count)、rangeLong(long start, long count)</strong></p><blockquote><p>创建一个Observable对象，发送一个事件序列，序列每次递增1，可指定开始位置和发送事件总数，没有延迟。</p><p>rangeLong支持Long类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">2</span>,<span class="number">10</span>).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Log.d(TAG,<span class="string">"下游收到数据 : "</span>+integer);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：2 3 4 ... 11，从2开始，发送10个事件。</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-变换操作符"><a href="#2-变换操作符" class="headerlink" title="2. 变换操作符"></a>2. 变换操作符</h3><p><strong>1. map(Function&lt;? super T, ? extends R&gt; mapper)</strong></p><blockquote><p>将上游Observable发送的每一个事件通过指定函数，转变为任意类型的事件。<br>比如：将Integer类型的数据转换为String类型数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"变换 "</span>+integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"下游收到数据 : "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：变换1 变换2 变换3 变换4，将数值1234前面增加了文字变成String类型。</span></span><br></pre></td></tr></table></figure><p><strong>2.1  flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)\ concatMap</strong></p><p><strong>2.2  flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper,BiFunction&lt;? super T, ? super U, ? extends R&gt; resultSelector)</strong></p><p><strong>2.3  concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch)</strong></p><blockquote><p>flatMap\concatMap 使用一个指定的函数对原始Observable发射的每一项数据之行相应的变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。</p><p>比如：上游O1发送了事件1,2,3，然后经过flatMap\concatMap操作符可以将：<br>—–&gt;事件1变换成有Oa发送的1a、1b事件，<br>—–&gt;事件2变换成由Ob发送的2a、2b事件，<br>—–&gt;事件3变换成有Oc发送的3a、3b事件，<br>然后flatMap\concatMap还会将上面的6个事件合并，当做原始Observable的事件发送给下游。</p><p><strong>注意：</strong></p><ol><li><p>flatMap\concatMap变换后下游收到的事件数量 = 变换后事件数量的总和，与原始Observable发送的事件数量无关。</p></li><li><p><strong>flatMap的变换是无序的，</strong>比如原始Observable发送数据顺序为：1,2,3，经过flatMap转换之后下游收到的事件顺序可以是：1a、3a、2a、2b、1b、3b。</p></li><li><p><strong>concatMap的变换是有序的，严格按照原始Observable的事件发送顺序，</strong>比如原始Observable发送数据顺序为：1,2,3，经过flatMap转换之后下游收到的事件顺序一定是：1a、1b、2a、2b、3a、3b。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上游发送了一批学生的信息，要求下游不进行遍历就可以收到每个学生的每一门课程的名称.</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Student&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//发送每一个学生信息给下游(List数据此处未展示)</span></span><br><span class="line">            emitter.onNext(getStudents().get(<span class="number">0</span>));</span><br><span class="line">            emitter.onNext(getStudents().get(<span class="number">1</span>));</span><br><span class="line">            emitter.onNext(getStudents().get(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//flatMap无序</span></span><br><span class="line">    .flatMap(<span class="keyword">new</span> Function&lt;Student, ObservableSource&lt;Classes&gt;&gt;() &#123;</span><br><span class="line">    <span class="comment">//concatMap有序</span></span><br><span class="line">    <span class="comment">//.concatMap(new Function&lt;Student, ObservableSource&lt;Classes&gt;&gt;() &#123;</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObservableSource&lt;Classes&gt; <span class="title">apply</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将学生信息转换为课程信息，获取每一个学生课程信息的集合，然后fromIterable会逐个将课程名称发送给下游。</span></span><br><span class="line">            <span class="keyword">return</span> Observable.fromIterable(student.className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Classes&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Classes classes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//下游直接获取到的就是每个学生每一门课程名称，不需要再次遍历。</span></span><br><span class="line">            Log.d(TAG,<span class="string">"下游收到数据 ： "</span>+classes.cName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">1</span>--课程<span class="number">1</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">1</span>--课程<span class="number">2</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">1</span>--课程<span class="number">3</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">2</span>--课程<span class="number">1</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">2</span>--课程<span class="number">2</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">2</span>--课程<span class="number">3</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">3</span>--课程<span class="number">1</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">3</span>--课程<span class="number">2</span></span><br><span class="line">下游收到数据 ： 学生<span class="number">3</span>--课程<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>3. buffer(long timespan, TimeUnit unit, Scheduler scheduler)  、 buffer(ObservableSource<b> boundary, Callable<u> bufferSupplier)</u></b></strong></p><blockquote><p>定期从Observable中获取指定数量的事件，先存到缓存区，然后再组装成一个集合发送给下游。</p><p>//参数count表示缓存区大小，当只有一个参数时，默认skip=count<br><strong>buffer(int count)</strong><br>//参数skip表示获取新事件的数量。<br><strong>buffer(int count, int skip)</strong></p><p><strong>注意：</strong></p><ol><li>如果缓存区小于新事件获取数量，就会存在因为取到的事件无法缓存，导致部分事件无法发送到下游的情况。<br>比如：原始Observable有1、2、3、4、5、6、7、8事件，缓存区大小count=2，每次取新事件skip=3，那么下游收到的数据为：1、2、4、5、7、8。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">    .just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    .buffer(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;Integer&gt; integers)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">" 事件数量 = "</span> + integers.size());</span><br><span class="line">            <span class="keyword">for</span> (Integer value : integers) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">" 接收事件 = "</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">事件数量 = <span class="number">6</span></span><br><span class="line">接收到的数据只有：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-组合、合并操作符"><a href="#3-组合、合并操作符" class="headerlink" title="3. 组合、合并操作符"></a>3. 组合、合并操作符</h3><p><strong>1. concat(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) 、 concat(ObservableSource&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) 、  concatArray(ObservableSource&lt;? extends T&gt;… sources)</strong></p><blockquote><p>组合多个被观察者Observable一起发送数据，合并后按之前合并顺序串行发送事件，concat组合数量≤4，concatArray组合数量&gt;4.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Observable.concat(</span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">    Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">    Observable.just(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">    Observable.just(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：1 2 3 4 5 6 7 8 9 ....</span></span><br></pre></td></tr></table></figure><p><strong>2. merge(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) 、 merge(ObservableSource&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) 、  mergeArray(ObservableSource&lt;? extends T&gt;… sources)</strong></p><blockquote><p>组合多个被观察者Observable一起发送数据，合并后按之前合并顺序并行发送事件，即同时发送事件，merge组合数量≤4，margeArray组合数量&gt;4.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.merge(</span><br><span class="line"><span class="comment">//参数：开始位置、发送事件总数、第一次发送延迟时间、每次发送间隔时间</span></span><br><span class="line">    Observable.intervalRange(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS), </span><br><span class="line">    Observable.intervalRange(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：0 2 -- 1 3 -- 2 4</span></span><br></pre></td></tr></table></figure><p><strong>3.1  concatDelayError(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)  </strong></p><p><strong>3.2  mergeDelayError(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) 、 mergeDelayError(ObservableSource&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)</strong> </p><blockquote><p><strong>使用情况：</strong>当使用concat、merge操作符时，如果组合中某个observable发送了error事件，则会立即终止其他observable发送其他事件。</p><p><strong>解决方案：</strong> 若希望onError事件推迟到其他所有observable发送事件结束之后才触发，可以使用concatDelayError \ mergeDelayError操作符。</p><p><strong>案例：</strong>比如observable1和observable2，当o1发送了error事件时，o1就停止发送其他事件了，那么此时o2也将不再发送其他事件，如果使用concatDelayError \ mergeDelayError则可以发送完所有事件之后，再触发error事件。</p><p><strong>疑问：</strong>如果有observable同时发送了onError和onComplete事件，那么使用了concatDelayError \ mergeDelayError后，还会触发之前的oEerror事件吗？<br><strong>答：</strong>onComplete和onError事件不会同时发送，所以发送了complete就不会有error，反之也一样。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.concatArrayDelayError(</span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    emitter.onNext(<span class="number">1</span>);</span><br><span class="line">    emitter.onNext(<span class="number">2</span>);</span><br><span class="line">    emitter.onNext(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 发送Error事件，因为使用了concatDelayError，所以第2个Observable将会发送事件，等发送完毕后，再发送错误事件</span></span><br><span class="line">    emitter.onError(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">    emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;),Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：1 2 3 4 5 6 onError事件错误信息</span></span><br></pre></td></tr></table></figure><p><strong>4.1  zip(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources, Function&lt;? super Object[], ? extends R&gt; zipper)</strong></p><p><strong>4.2  zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2,BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper)</strong></p><blockquote><p>组合多个Observable，但是严格按照每个Observable发送的事件序列进行位置合并，即A1-B1,A2-B2,A3-B3…，并且合并后事件的数量是根据Observable中事件数量最少的来决定的。</p><p>下游收到的事件数量和上游众多Observable中事件数量最少的那个一致，虽然多余的事件也会发送，但是下游不会收到。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Observable o1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"o1 发送事件 1"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"o1 发送事件 2"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"o1 发送事件 3"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                Log.d(TAG,<span class="string">"o1 发送事件 onComplete"</span>);</span><br><span class="line">                 emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">        Observable o2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"o2 发送事件 A"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"A"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"o2 发送事件 B"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"B"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"o2 发送事件 C"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"C"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"o2 发送事件 D"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"D"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"o2 发送事件 onComplete"</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.newThread());</span><br><span class="line"></span><br><span class="line">        Observable.zip(o1, o2, <span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"zip 开始进行合并-------------"</span>);</span><br><span class="line">                <span class="keyword">return</span> integer + s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游收到 zip 合并结果  s = "</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游结束-------------"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：1A 2B 3C； 但是事件D也会发送，不过下游不会收到。</span></span><br></pre></td></tr></table></figure><p><strong>5.1  combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2,BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner) </strong></p><p><strong>5.2  combineLatestDelayError(Function&lt;? super Object[], ? extends R&gt; combiner,int bufferSize, ObservableSource&lt;? extends T&gt;… sources)</strong></p><blockquote><p>假设上游有n个Observable，将前面n-1个Observable发送的最后一个数据，与第n个Observable的每一个数据进行相应的函数结合(可以相加、相乘等)，然后将结合的数据发送给下游。</p><p>比如：上游的Observable有A(1,2,3)，B(5,6,7,8)，C(A、B、C、D)，然后结合的方式是相加，那么结合的过程就是：A中的最后一个数据A(3)和B中的最后一个数据B(8)相加，然后与C中的每一个数据进行相加。</p><p>下游收到的事件数量取决于最后一个Observable中事件的数量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.combineLatest(</span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">    Observable.just(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>),</span><br><span class="line">    Observable.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>),</span><br><span class="line">    <span class="keyword">new</span> Function3&lt;Integer, Integer, String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer, Integer aLong, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Log.d(TAG, <span class="string">"合并事件  integer = "</span> + integer + <span class="string">",  aLong = "</span> + aLong + <span class="string">",   s = "</span> + s);</span><br><span class="line"><span class="keyword">return</span> integer + aLong + s;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"下游收到合并结果 = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：11A 11B 11C 11D; O1和O2的最后一个数据相加：3+8=11，然后再与O3的每个数据相加。</span></span><br></pre></td></tr></table></figure><p><strong>6. reduce(BiFunction&lt;T, T, T&gt; reducer) </strong></p><blockquote><p>将Observable中需要发送的事件全部聚合成一个事件，然后在发送出去。<br>比如：Observable中与事件a=1、b=2、c=3、d=4，那么聚合过程就是：a与b进行聚合，然后在与c进行聚合，然后在与d进行聚合，将得到的最终结果发送给下游。</p><p>如果是聚合函数是相乘，那么就是：1 <em> 2，然后2 </em> 3，然后6 * 4，最终得到数据24发送给下游。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .reduce(<span class="keyword">new</span> BiFunction&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer integer, Integer integer2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//integer表示合并之后的结果，integer2表示发送过来的新数据</span></span><br><span class="line">        <span class="keyword">return</span> integer * integer2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"下游 ："</span>+integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：24；这里做的是乘法运算：1*2=2,2*3=6,6*4=24这样一个过程，使用前面两个数据的结果，在与后一个数据进行计算，以此类推。</span></span><br></pre></td></tr></table></figure><p><strong>7. collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector)</strong></p><blockquote><p>将Observable发送的数据整合到一个数据结构中。<br>比如：Observable发送数据：1,2,3,4，通过collect操作符整合，发送给下游的可以是一个List&lt;&gt;集合,集合中包含以上数据。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">  .collect(<span class="keyword">new</span> Callable&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//第一步：创建一个数据结构容器，用于收集Observable发送的数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> BiConsumer&lt;ArrayList&lt;Integer&gt;, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ArrayList&lt;Integer&gt; integers, Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//参数integers是前面创建的数据结构，参数integer是发送过来的数据，这里可以增加条件，收集需要的数据</span></span><br><span class="line">                <span class="keyword">if</span>(integer % <span class="number">2</span> == <span class="number">0</span>)  integers.add(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ArrayList&lt;Integer&gt; integers)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> data : integers)&#123;</span><br><span class="line">                    Log.d(TAG,<span class="string">"下游收到的数据包含 ： "</span>+data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>8. startWith(Iterable&lt;? extends T&gt; items) 、 startWith(ObservableSource&lt;? extends T&gt; other) 、  startWithArray(T… items)</strong></p><blockquote><p>在一个Observable发送数据之前，追加发送一些数据或者一个新的Observable，追加的数据在原有数据之前，比如原来是：1,2,3，追加数据是：4,5,6，那么下游收到数据的顺序是：4,5,6,1,2,3。</p><p>追加一个数据使用startWith(2)，追加多个数据使用startWithArray(2,3,4)，两者可以同时使用，遵循后追加的数据在前的原则。</p><p>需要追加新的Observable只能使用startWith操作符。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .startWith(Observable.just(<span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">    .startWithArray(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"下游收到的数据包含 ： "</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//输出结果：4 5 6 8 9 1 2 3；后追加的在前面输出。</span></span><br></pre></td></tr></table></figure><p><strong>9. count()</strong></p><blockquote><p>统计被观察者发送事件的数量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">          .startWithArray(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">          .count()</span><br><span class="line">          .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  Log.e(TAG, <span class="string">"发送的事件数量 =  "</span>+aLong);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          </span><br><span class="line"><span class="comment">//此处会统计两次发送的事件</span></span><br><span class="line">发送的事件数量 = <span class="number">7</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-功能性操作符"><a href="#4-功能性操作符" class="headerlink" title="4. 功能性操作符"></a>4. 功能性操作符</h3><p><strong>1. delay</strong></p><blockquote><p><strong>使得被观察者延迟一段时间再发送事件。</strong></p><p>// 1. 参数delay是延迟时间；参数unit是时间单位<br><strong>delay(long delay,TimeUnit unit)</strong></p><p>// 2. 参数scheduler是线程调度器<br><strong>delay(long delay,TimeUnit unit,mScheduler scheduler)</strong></p><p>// 3.参数delayError是是否延迟发送错误消息<br>// 如果delayError = true，表示会正常发送完前面的事件，然后在发送错误消息<br>// 如果delayError = false，表示直接发送错误消息，前面的事件都不发送了<br><strong>delay(long delay,TimeUnit unit,boolean delayError)</strong><br><strong>delay(long delay,TimeUnit unit,mScheduler scheduler,boolean delayError):</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                emitter.onError(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).delay(<span class="number">2</span>,TimeUnit.SECONDS,<span class="keyword">false</span>)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG,<span class="string">"onNext下游收到事件 ： "</span>+integer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG,<span class="string">"onError下游收到事件 ： "</span>+e.toString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志信息</span></span><br><span class="line"><span class="keyword">true</span> ： </span><br><span class="line">onNext下游收到事件 ： <span class="number">1</span></span><br><span class="line">onNext下游收到事件 ： <span class="number">2</span></span><br><span class="line">onError下游收到事件 ： java.lang.NullPointerException</span><br><span class="line"></span><br><span class="line"><span class="keyword">false</span>：</span><br><span class="line">onError下游收到事件 ： java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p><strong>2. do操作符</strong></p><blockquote><p>do操作符只是一种总称，包含doOnComplete 、doOnNext、 doAfterNext 、doOnEach等等，主要是在订阅的整个生命周期的不同阶段进行不同的操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="number">1</span>);</span><br><span class="line">                e.onNext(<span class="number">2</span>);</span><br><span class="line">                e.onNext(<span class="number">3</span>);</span><br><span class="line">                e.onError(<span class="keyword">new</span> Throwable(<span class="string">"发生错误了"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnEach(<span class="keyword">new</span> Consumer&lt;Notification&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="comment">// 1. 当Observable每发送1次数据事件就会调用1次</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Notification&lt;Integer&gt; integerNotification)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnEach: "</span> + integerNotification.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 2. 执行Next事件前调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnNext: "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doAfterNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 3. 执行Next事件后调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doAfterNext: "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnComplete(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">            <span class="comment">// 4. Observable正常发送事件完毕后调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"doOnComplete: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnError(<span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="comment">// 5. Observable发送错误事件时调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnError: "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnSubscribe(<span class="keyword">new</span> Consumer&lt;Disposable&gt;() &#123;</span><br><span class="line">            <span class="comment">// 6. 观察者订阅时调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(@NonNull Disposable disposable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"doOnSubscribe: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doAfterTerminate(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">            <span class="comment">// 7. Observable发送事件完毕后调用，无论正常发送完毕 / 异常终止</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"doAfterTerminate: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doFinally(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">            <span class="comment">// 8. 最后执行</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"doFinally: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3. onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier)</strong></p><blockquote><p>当遇到错误或者异常时，可以捕获在它之前的错误，并发送一个自己定义的事件给下游，然后正常终止，不会因为前面的错误而出现异常。<br>同时onErrorReturn操作符重新发送的事件，下游也是在onNext回调中收到，不是在onError中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                emitter.onNext(<span class="string">"AA"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"BB"</span>);</span><br><span class="line">                emitter.onError(<span class="keyword">new</span> Throwable(<span class="string">"上游突然发生了错误"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).onErrorReturn(<span class="keyword">new</span> Function&lt;Throwable, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我知道上游发生了错误，没关系，我来拯救。"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"下游onNext收到数据 : "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"下游onError收到数据 : "</span>+e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>4. onErrorResumeNext(final ObservableSource&lt;? extends T&gt; next) 、 onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction)</strong></p><blockquote><p>当遇到错误时重新定义一个新的Observable，然后使用新的Observable继续发送数据，发生错误之前正确发送的数据还是会发送给下游。</p><p><strong>注意：onErrorResumeNext可以捕获Throwable或者Exception类型的错误。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(...)</span><br><span class="line"><span class="comment">//主要代码，演示捕获异常</span></span><br><span class="line">.onErrorResumeNext(<span class="keyword">new</span> Function&lt;Throwable, ObservableSource&lt;? extends String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;? extends String&gt; apply(Throwable throwable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//重新定义新的Observable，发送事件</span></span><br><span class="line">                <span class="keyword">return</span> Observable.just(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p><strong>5. onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next)</strong></p><blockquote><p>当遇到错误时Exception类型的错误时，可以将其捕获，但是获取不到具体的错误信息，然后通过<code>new ObservableSource</code>获得一个观察者Observer对象，指定回调到下游的onNext、onError或者onComplete中。</p><p><strong>注意：onExceptionResumeNext无法捕获到Throwable类型的错误，错误信息会直接回调到下游的onError中。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(...)</span><br><span class="line"><span class="comment">//主要代码，演示捕获异常</span></span><br><span class="line">.onExceptionResumeNext(<span class="keyword">new</span> ObservableSource&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> String&gt; observer)</span> </span>&#123;</span><br><span class="line">                observer.onNext(<span class="string">"上游出现异常，我捕获到了。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>6. retry</strong></p><blockquote><p><strong>当发生错误时，让Observable重新发送数据，从第一个数据开始发送。</strong></p><p><strong>1. retry()</strong><br>出现错误时，让被观察者重新发送数据，若一直错误，则一直重新发送，直到成功了才停止，否则是死循环。</p><p><strong>2. retry(long times)</strong><br>出现错误时，让被观察者重新发送数据，参数表示重试次数，若重试结束还没有成功，就回调到下游的onError中。</p></blockquote><blockquote><p><strong>3. retry(Predicate&lt;? super Throwable&gt; predicate)</strong><br>出现错误后，判断是否需要重新发送数据，如果需要重新发送，但是一直是错误，就一直循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; Observable.create(...)</span><br><span class="line">&gt; .retry(<span class="keyword">new</span> Predicate&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"我获取到了错误信息 ： "</span>+throwable.toString());</span><br><span class="line">                <span class="comment">//true : 表示重试；false：不重试，就直接回调到下游的onError中。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>4. retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate)</strong><br>出现错误后，判断是否需要重新发送数据，增加了重试次数，可以进行相关判断，如果在重试n次之后还是错误，就回调到下游的onError中结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; Observable.create(...)</span><br><span class="line">&gt; .retry(<span class="keyword">new</span> BiPredicate&lt;Integer, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer, Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"重试次数 = "</span>+integer);</span><br><span class="line">                Log.d(TAG,<span class="string">"错误消息 = "</span>+throwable.toString());</span><br><span class="line">                <span class="keyword">if</span>(integer == <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>5. retry(long times, Predicate&lt;? super Throwable&gt; predicate)</strong><br>出现错误后，判断是否需要重新发送数据，如果需要则会根据前面第一个参数进行n次重试，如果之后还是错误，则回调到下游的onError中结束。</p></blockquote><p><strong>7. retryUntil(final BooleanSupplier stop)</strong></p><blockquote><p><strong>上游错误后，判断是否需要重新发送数据。</strong></p><p><strong>true：</strong>不重试，拦截错误返回给下游的onError。<br><strong>false：</strong>重试，如果一直失败就会一直重试。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(...)</span><br><span class="line">.retryUntil(<span class="keyword">new</span> BooleanSupplier() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAsBoolean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"我拦截上游错误----"</span>);</span><br><span class="line">                <span class="comment">//true：拦截错误回调给下游的onError， false：重试</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p><strong>8. retryWhen(final Function&lt;? super Observable<throwable>, ? extends ObservableSource&lt;?&gt;&gt; handler)</throwable></strong></p><blockquote><p>当出现错误时，将发生的错误(比如Throwable错误)传递给一个新的Observable，并由新的这个Observable来决定是否需要原始的Observable重新发送事件。<br><strong>注意：</strong></p><ol><li><p>当新的Observable返回onNext事件时，会进行重试，如果原始的Observable一直失败，就一直重试，如果成功了，新的Observable发送的事件不会发送到下游。</p></li><li><p>当新的Observable返回error(比如Observable.error(new Thrwoable(“error”)))事件时，不进行重试，而是直接回调到下游的onError事件中。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(...)</span><br><span class="line">.retryWhen(<span class="keyword">new</span> Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> throwableObservable.flatMap(<span class="keyword">new</span> Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Throwable throwable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//直接返回error则不会进行重试，而是回调到下游的onError中。</span></span><br><span class="line">                <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"retryWhen 中终止错误，不重试。"</span>));</span><br><span class="line">                <span class="comment">//如果是重新发送事件，则会进行重试，原始的Observable一直失败就一直重试，如果成功了，这里发送的事件是不会发送到下游的。</span></span><br><span class="line"><span class="keyword">return</span> Observable.just(<span class="string">"A"</span>,<span class="string">"B"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><strong>9. repeat() 、repeat(long times)</strong></p><blockquote><p>无条件的重复发送Observable的事件，可以传递参数控制重复次数，如果遇到错误，就不会重复发送事件了。</p><p><strong>注意：是重复发送正确的事件，是不是遇到错误进行重试。</strong></p></blockquote><p><strong>10. repeatWhen(final Function&lt;? super Observable<object>, ? extends ObservableSource&lt;?&gt;&gt; handler)</object></strong></p><blockquote><p><strong>有条件的重复发送Observable的事件。</strong></p><p><strong>原理：</strong>repeatWhen操作符是将上游Observable停止发送事件的标识(比如onError和onComplete都标识停止发送事件)转换成一个Object类型的数据，传递给一个新的Observable，然后由新的Observable来决定是否重复发送数据。</p><p><strong>条件：</strong><br><strong>1. 不重复发送：</strong>当新的Observable返回onComplete或onError事件时，则不重复发送原始Observable的数据。</p><p><strong>2. 重复发送：</strong>当新的Observable发送正常事件，比如onNext事件时，则重复发送原始的Observable的数据，新的Observable数据不会发送给下游，只是一个标识而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; Observable.create(...)</span><br><span class="line">&gt; .repeatWhen(<span class="keyword">new</span> Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> objectObservable.flatMap(<span class="keyword">new</span> Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Object o) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"我来决定是否重复--"</span>);</span><br><span class="line">                <span class="comment">//1. 只是发送了一个onConplete事件，下游并不会收到onComple回调，所以不会进行重复发送。</span></span><br><span class="line">                <span class="comment">//return Observable.empty();</span></span><br><span class="line">                <span class="comment">//2. 发送了error事件，不会进行重复发送，并且error会回调到下游的onError中。</span></span><br><span class="line">                <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"我要终止"</span>));</span><br><span class="line">                <span class="comment">//3. 发送的是onNext事件，所以会重复发送原始的Observable的事件，并一直重复。</span></span><br><span class="line">                <span class="comment">//return Observable.just(1);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="5-过滤操作符"><a href="#5-过滤操作符" class="headerlink" title="5. 过滤操作符"></a>5. 过滤操作符</h3><p><strong>1. filter(Predicate&lt;? super T&gt; predicate)</strong></p><blockquote><p>根据特定的条件过滤上游Observable发送的事件。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤比3小的事件</span></span><br><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//根据test()的返回值进行过滤，true：过滤，false：不过滤。</span></span><br><span class="line">                <span class="keyword">return</span> integer &gt;=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"下游收到事件 : "</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：3 4 5 6，此处不小于3的事件就被过滤了。</span></span><br></pre></td></tr></table></figure><p><strong>2. ofType(final Class&lt;?&gt; clazz)</strong></p><blockquote><p>根据指定的数据类型进行过滤，比如：Integer、String等，符合条件的会发送给下游，不符合条件的就直接抛弃。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="string">"rxjava"</span>,<span class="number">3</span>,<span class="string">"android"</span>,<span class="number">5</span>)</span><br><span class="line">          <span class="comment">//将String类型的数据发送给下游，其他类型的都抛弃</span></span><br><span class="line">            .ofType(String.class).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"下游收到事件 : "</span>+s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：rxjava android，整型事件都被过滤了。</span></span><br></pre></td></tr></table></figure><p><strong>3. skipLast(long time, TimeUnit unit, Scheduler scheduler)、skipLast(long time, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>从前面、后面跳过某个发送的事件。</p><p>//从前面、后面跳过指定时间内发送的数据。<br><strong>skip(long time, TimeUnit unit)</strong><br><strong>skipLast(long time, TimeUnit unit)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据数量进行筛选</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="string">"rxjava"</span>, <span class="number">3</span>, <span class="string">"android"</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">        <span class="comment">//跳过前面发送的两个事件</span></span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">//跳过后面发送的两个事件</span></span><br><span class="line">        .skipLast(<span class="number">2</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Serializable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Serializable serializable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游收到事件 : "</span> + serializable.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//输出结果：3 android 5，注意这里有Integer和String类型的数据，所以下游进行了序列化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据时间进行筛选</span></span><br><span class="line"><span class="comment">//这里是：从0开始，发送8个事件，第1个时间延时0s，以后每隔1s发送一个事件</span></span><br><span class="line">Observable.intervalRange(<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">//跳过前2s发送的事件，不论多少个事件都跳过</span></span><br><span class="line">        .skip(<span class="number">2</span>,TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">//跳过最后2s发送的事件，不论多少个事件都跳过</span></span><br><span class="line">        .skipLast(<span class="number">2</span>,TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Serializable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Serializable serializable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游收到事件2 : "</span> + serializable.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//输出结果：2 3 4 5 ，原本应该是：0 1 2 3 4 5 6 7</span></span><br></pre></td></tr></table></figure><p><strong>4. distinct() 、 distinct(Function&lt;? super T, K&gt; keySelector)、distinctUntilChange() 、 distinctUntilChanged(Function&lt;? super T, K&gt; keySelector)</strong></p><blockquote><p><strong>distinct：</strong>过滤事件序列中重复的事件，即前面出现过的，全部过滤掉。</p><p><strong>distinctUntilChange：</strong>过滤事件序列中连续重复的事件，即使前面有出现过也没关系，只要不是连续重复的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 过滤重复数据，只要出现过的就过滤掉</span></span><br><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游收到事件: "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//输出结果：1 2 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 过滤掉连续重复的数据</span></span><br><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"下游收到事件2 : "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//输出结果：1 2 4 5 1 2 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 过滤集合中重复的数据或者连续重复的数据</span></span><br><span class="line"><span class="comment">//简化Students设置的过程，最终返回一个包含20条数据的集合。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        student.setScode(<span class="string">"2"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        student.setScode(<span class="string">"3"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        student.setScode(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从集合中根据scode进行重复、连续重复过滤</span></span><br><span class="line">Observable.fromIterable(getStudents())</span><br><span class="line">        .distinct(<span class="keyword">new</span> Function&lt;Student, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.getScode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).flatMap(<span class="keyword">new</span> Function&lt;Student, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用flatMap进行变换，下游直接拿到需要的数据</span></span><br><span class="line">        <span class="keyword">return</span> Observable.just(student.name+<span class="string">" - "</span>+student.scode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"下游收到事件3: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//distinct:学生-1-1,学生-2-2, 学生-3-3，一起只有3条数据。</span></span><br><span class="line"><span class="comment">//distinceUntilChanged:学生-1-1 ... 学生-19-1,一起20条数据全部输出，因为按照上面的方式设置的集合，不存在连续重复。</span></span><br></pre></td></tr></table></figure><p><strong>5. take(long time, TimeUnit unit, Scheduler scheduler)、takeLast(long count, long time, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>指定下游只能接受前n个、后n个数据，上游有多少个数据还是会正常发送，只是在中间被从前、后取出n个发送给下游。</p><p><strong>takeLast取事件时上游一定要调用onComplete，确认事件发送完毕，否则取不到事件。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去最后发送的两个事件</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"上游发送事件 ： 1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"上游发送事件 ： 2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"上游发送事件 ： 3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"上游发送事件 ： 4"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"上游发送事件 ： 5"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//一定记得发送onComplete事件，否则从后取事件时会认为上游事件没有发送完毕，取不到事件。</span></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).takeLast(<span class="number">2</span>).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"下游事件 ："</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：4 5</span></span><br></pre></td></tr></table></figure><p><strong>6. throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler)、throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>在某段时间内，只发送该段时间内的第一次、最后一次的事件。<br><strong>注意：</strong></p><ol><li>使用throttleFirst时，onComplete或者onError方法始终会发送，即使在该段时间内已经发送了其他事件。</li><li>使用throttleLast时，如果onComplete或者onError在间隔事件内，和前一个事件同时发送时，前一个事件将不被发送，只发送onComplete或onError会。</li></ol><p><strong>应用场景：</strong>发送短信验证码时，在几秒钟之内连续点击多次，只响应第一次点击事件，发送一个短信验证码。</p><p><strong>比如：</strong>每间隔0.5s发送1 2 3 4 5 6 7 8等事件，而throttleFirst设置的间隔时间是1s，那么最终发送的事件就会是：1 3 5 7。</p><p><strong>盗图说明：</strong><br><img src="https://i.loli.net/2019/04/20/5cba8c9cced2a.png" alt="Alt text"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onNext(<span class="number">5</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这里事件6将不会发送，取而代之的是onComplete事件</span></span><br><span class="line">        emitter.onNext(<span class="number">6</span>);             </span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).throttleLast(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onNext下游事件 ："</span>+integer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onError下游事件 ："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete下游事件 ："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">throttleFirst：<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> onComplete，最后的onComplete依然会发送，即使在间隔时间内有其他事件发送了。</span><br><span class="line">throttleLast：<span class="number">2</span> <span class="number">4</span> onComplete，事件<span class="number">6</span>将不会发送。</span><br></pre></td></tr></table></figure><p><strong>7. sample(long period, TimeUnit unit, Scheduler scheduler) 、 sample(ObservableSource&lt;?&gt; sampler)</strong></p><blockquote><p>在某段时间内，只发送该时间内最后一次事件，与上面的throttleLast用法一致，其实throttleLast内部调用的就是sample。</p></blockquote><p><strong>8. throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler)、 debounce(long timeout, TimeUnit unit, Scheduler scheduler)</strong></p><blockquote><p>发送数据事件时，如果两个事件之间的时间间隔 &lt; 指定时间，则抛弃前一次发送的事件，直到指定时间内再没有新的数据事件发送时，才会发送最后一次的事件。</p><p>比如：指定间隔事件是2s，然后开始发送A，等待1s后，发送B，然后等待1s后，发送C，然后等待2s发送D，此时下游收到数据：C和D。<br>—— &gt; 因为A-B之间间隔不足2s，事件A被抛弃；<br>—— &gt; 而B-C之间间隔也不足2s，事件B被抛弃；<br>—— &gt; 最后C-D之间间隔了2s，所以事件C被保留发送给下游，事件D之后没有发送其他事件了，那么事件D也会发送给下游。</p><p><strong>注意：</strong><br><strong>1. onComplete和onError事件不受限制，即使和前一个事件的间隔小于指定时间，同样会发送给下游。</strong></p><p><strong>2. debounce(Function&lt;? super T, ? extends ObservableSource&lt;?&gt;&gt;  debounceSelector) 还可以重新定义一个Observable，对发送的数据进行判断</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//1和2之间间隔小于2s，事件1被抛弃</span></span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//2和3之间间隔刚好2s，事件2被保留，事件3之后只有onComplete事件，没有其他事件，所以事件3也被保留发送。</span></span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).throttleWithTimeout(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onNext下游事件 ："</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onError下游事件 ："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete下游事件 ："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//输出结果：2 3 onComplete，onComplete不管间隔时间是多少都会发送。</span></span><br></pre></td></tr></table></figure><p><strong>9. firstElement() 、 lastElement()</strong></p><blockquote><p>仅选取第一个、最后一个事件发送给下游。<br>包含onComplete时。两者都不会发送个下游，但如果是onError时，lastElement会发送给下游，并且不发送其他事件。</p><p><strong>注意：firstElement 、 lastElement返回类型是Maybe，所以下游使用的是new MaybeObserver。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).lastElement().subscribe(<span class="keyword">new</span> MaybeObserver&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"数据 : "</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"数据onComplete "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//firstElement：1</span></span><br><span class="line"><span class="comment">//lastElement：3</span></span><br></pre></td></tr></table></figure><p><strong>10. elementAt(long index) 、elementAt(long index, T defaultItem)</strong></p><blockquote><p>接收指定索引位置的事件，允许越界，也不会抛出异常，越界时可以指定默认值。即使有onComplete事件也不会发送给下游。</p><p>//参数index表示索引位置，索引从0开始。<br><strong>Maybe<t> elementAt(long index)</t></strong><br>//参数defaultItem表示越界后设置的默认值。<br><strong>Single<t> elementAt(long index, T defaultItem)</t></strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).elementAt(<span class="number">8</span>,<span class="number">99</span>).subscribe(<span class="keyword">new</span> SingleObserver&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"数据 : "</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"onError "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//输出结果：99，越界之后输出指定的默认值。</span></span><br></pre></td></tr></table></figure><p><strong>11. elementAtOrError(long index)</strong></p><blockquote><p>接收指定索引位置的事件，如果越界会抛出异常。</p><p>//参数index表示索引位置<br><strong>Single<t> elementAtOrError(long index)</t></strong><br>注意：</p><ol><li>如果下游订阅时使用的是：subscribe(new SingleObserver&lt;&gt;())，如果越界了会回调到下游的onError方法中，并不会奔溃。</li><li>如果下游订阅时使用的是：subscribe(new Consumer&lt;&gt;())，如果越界了，会导致程序奔溃。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).elementAtOrError(<span class="number">8</span>).subscribe(<span class="keyword">new</span> SingleObserver&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"发生onSuccess"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"发生error : "</span>+e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：抛出异常，回调到onError中。</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-条件、布尔操作符"><a href="#6-条件、布尔操作符" class="headerlink" title="6. 条件、布尔操作符"></a>6. 条件、布尔操作符</h3><p><strong>1. all(Predicate&lt;? super T&gt; predicate)</strong></p><blockquote><p>判断发送的每个数据是否满足条件，满足返回true，不满足返回false。</p><p><strong>注意：返回的不是发送的数据具体的值，并且会逐一判断每个发送的数据。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        .all(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> integer&gt;<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"满足条件: "</span>+aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:前面三个数都&gt;2,但是1&lt;2,所以最终结果是:false</span></span><br></pre></td></tr></table></figure><p><strong>2. takeWhile(Predicate&lt;? super T&gt; predicate)</strong></p><blockquote><p>判断发送的每个数据是否满足特定条件，如果满足就发送，不满足就不发送给下游。</p><p><strong>注意：发送的是满足条件的数据的值</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        .takeWhile(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> integer&gt;<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"收到数据 :"</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：3 4 5</span></span><br></pre></td></tr></table></figure><p><strong>3. skipWhile(Predicate&lt;? super T&gt; predicate)</strong></p><blockquote><p>判断发送的每个数据是否满足特定的条件，如果满足(true)就不发送给下游，直到不满足(false)时，才把开始把后续的所有数据都发给下游，不管条件是否满足。(<strong>一次满足即可</strong>)<br><strong>注意：一定是返回false时，才开始发送数据，之前的不会发送。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .skipWhile(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> integer&gt;<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"收到数据 :"</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：1 0 6 5，从1开始返回false的，后续就直接发送，不管判断条件。</span></span><br></pre></td></tr></table></figure><p><strong>4. takeUntil(ObservableSource&lt;?&gt; other)  、 takeUntil(Predicate&lt;? super T&gt; stopPredicate)</strong></p><blockquote><p>判断发送的每个数据是否满足特定条件，不满足时发送数据，直到满足条件时停止发送，满足条件的这一个数据还是会发送的，后续的就不发了。</p><p><strong>注意：满足条件时才停止，不满足时却是发送数据的。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>)</span><br><span class="line">        .takeUntil(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> integer&gt;<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"收到数据 :"</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：-1 1 0 2 6，正好6满足条件，后面的1就不发送了。</span></span><br></pre></td></tr></table></figure><p><strong>5. skipUntil(ObservableSource<u> other)</u></strong></p><blockquote><p>skipUntil传入的是Observable，当传入的Observable开始发送数据时，原始的Observable才开始发送数据，相当于新的Observable是原始Observable发送数据的开关。</p><p><strong>注意：当新传入的Observable开始发送数据时，原始的Observable先于该时间点发送的数据，将不会发送给下游。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔1s发送一个数据，数据从0开始发送，每次递增1</span></span><br><span class="line">Observable.interval(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line"><span class="comment">//延时5s开始发送数据</span></span><br><span class="line">        .skipUntil(Observable.timer(<span class="number">5</span>,TimeUnit.SECONDS))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"onSubscribe---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"下游收到数据 :"</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"onError :"</span>+e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"onComplete---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：4 5 6 7 8....，前面已经发送的数据(0 1 2 3)不会发给下游</span></span><br><span class="line"><span class="comment">//如果上游是一下子发送完了数据，这里新传入的Observable延时了5s，那么下游就收不到任何数据了，直接回调到onComplete。</span></span><br></pre></td></tr></table></figure><p><strong>6. sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)</strong></p><blockquote><p>判断两个Observable发送的数据是否完全相同，相同返回true，不相同返回false。</p><p><strong>数据相同，顺序不同返回也是false。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">    Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">    Observable.just(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"输出结果:"</span>+aBoolean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//输出结果:false,数据顺序不一致，也是false。</span></span><br></pre></td></tr></table></figure><p><strong>7. contains(final Object element) </strong></p><blockquote><p>发送的数据中是否包含指定的数据，包含返回true，不包含返回false。</p><p><strong>内部实现：any(Predicate&lt;? super T&gt; predicate)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .contains(<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"输出结果:"</span>+aBoolean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//输出结果：true</span></span><br></pre></td></tr></table></figure><p><strong>8. isEmpty()</strong></p><blockquote><p>判断发送的数据是否为空，若为空，返回true，不为空，返回false。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">""</span>,<span class="string">"C"</span>)</span><br><span class="line">    .isEmpty()</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"输出结果:"</span>+aBoolean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//输出结果:false,即使传的是""也不会认为是空的</span></span><br></pre></td></tr></table></figure><p><strong>9. amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) </strong></p><blockquote><p> 当需要发送多个Observable的数据时，只发送最先发送了数据的Observable的数据，其余Observable的数据抛弃。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ObservableSource&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).delay(<span class="number">1</span>,TimeUnit.SECONDS));</span><br><span class="line">list.add(Observable.just(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">Observable.amb(list).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Log.d(TAG,<span class="string">"收到数据 :"</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：4 5 6，因为第一个Observable发送数据延迟了1s，所以第二个会先发送数据，amb()操作符会使得第一个Observable的数据被抛弃</span></span><br></pre></td></tr></table></figure><p><strong>10. defaultIfEmpty(T defaultItem)</strong></p><blockquote><p>在不发送任何有效事件(即onNext事件)、只发送onComplete事件的前提下，发送一个指定的默认值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//emitter.onNext("AA");</span></span><br><span class="line">        emitter.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).defaultIfEmpty(<span class="string">"BB"</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onNext 数据 ： "</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onError 数据 ： "</span>+e.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//输出结果：BB onComplete，如果是上游发送了onNext事件，就不会发送BB了。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RxJava系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作符 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义View方法查询手册-Canvas</title>
      <link href="/2019/04/14/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Canvas/"/>
      <url>/2019/04/14/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Canvas/</url>
      
        <content type="html"><![CDATA[<p><strong>系列文章</strong></p><p><a href="https://www.syncxiao.com/2019/03/07/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Paint">1. 自定义View方法查询手册-Paint</a></p><p><a href="https://www.syncxiao.com/2019/04/14/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Canvas">2. 自定义View方法查询手册-Canvas</a></p><hr><a id="more"></a><p><strong>1. 实心圆</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc8fd362d.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);</span><br><span class="line"><span class="comment">//参数分别表示：圆心X，圆心Y，圆形半径，画笔</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>2. 空心圆</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc8fe509d.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">paint2.setStrokeWidth(<span class="number">30</span>);</span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line"><span class="comment">//参数分别表示：圆心X，圆心Y，圆形半径，画笔</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>3. 直角矩形</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc8fe6137.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数分别表示：left、top、right、bottom，即左上角、右下角坐标的X、Y，画笔</span></span><br><span class="line">canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">600</span>,<span class="number">400</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>4. 直角矩形 - - Rect</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc90045d6.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Rect对象，分别设置左上角、右下角坐标</span></span><br><span class="line">Rect rect = <span class="keyword">new</span> Rect();</span><br><span class="line">rect.left = <span class="number">100</span>;</span><br><span class="line">rect.top = <span class="number">100</span>;</span><br><span class="line">rect.right = <span class="number">600</span>;</span><br><span class="line">rect.bottom = <span class="number">400</span>;</span><br><span class="line">canvas.drawRect(rect,paint);</span><br></pre></td></tr></table></figure><p><strong>5. 圆角矩形</strong><br><img src="https://i.loli.net/2019/04/14/5cb2beca6dd8a.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RectF rect = <span class="keyword">new</span> RectF();</span><br><span class="line">rect.left = <span class="number">100</span>;</span><br><span class="line">rect.top = <span class="number">100</span>;</span><br><span class="line">rect.right = <span class="number">600</span>;</span><br><span class="line">rect.bottom = <span class="number">400</span>;</span><br><span class="line"><span class="comment">//参数分别表示：矩形、X轴、Y轴方向的圆角半径、画笔</span></span><br><span class="line">canvas.drawRoundRect(rect,<span class="number">20</span>,<span class="number">20</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>6. 小圆点、小方块</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc9005bbb.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置小圆点的大小</span></span><br><span class="line">paint.setStrokeWidth(<span class="number">50</span>);</span><br><span class="line"><span class="comment">//平头小方块</span></span><br><span class="line">paint.setStrokeCap(Paint.Cap.BUTT);</span><br><span class="line"><span class="comment">//参数分别是X、Y点坐标</span></span><br><span class="line">canvas.drawPoint(<span class="number">200</span>,<span class="number">400</span>,paint);</span><br><span class="line"><span class="comment">//小圆点</span></span><br><span class="line">paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">canvas.drawPoint(<span class="number">300</span>,<span class="number">400</span>,paint);</span><br><span class="line"><span class="comment">//方头小方块</span></span><br><span class="line">paint.setStrokeCap(Paint.Cap.SQUARE);</span><br><span class="line">canvas.drawPoint(<span class="number">400</span>,<span class="number">400</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>7. 连续小圆点、小方块</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc9005d85.jpg" alt="Alt text"></p><blockquote><p><strong>pts：</strong>坐标数组<br><strong>offset：</strong>跳过数组中前面几个数，才开始计算圆点坐标<br><strong>count：</strong>一起要多少个数组中的数来进行坐标圆点绘制，两个数算作一个点，越界会出现异常，单个数不算作一个点<br><strong>drawPoints(float[] pts, int offset, int count, Paint paint)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drawPoints(<span class="keyword">float</span>[] pts, <span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="meta">@RecentlyNonNull</span> Paint paint)</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span>[] points = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">100</span>&#125;;</span><br><span class="line">canvas.drawPoints(points,paint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span>[] points2 = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">100</span>,<span class="number">300</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">300</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">300</span>&#125;;</span><br><span class="line">canvas.drawPoints(points2,<span class="number">1</span>,<span class="number">6</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>8. 椭圆</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc9006b96.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//left、top、right、bottom位置的坐标</span></span><br><span class="line">canvas.drawOval(<span class="number">100</span>,<span class="number">100</span>,<span class="number">600</span>,<span class="number">400</span>,paint);</span><br><span class="line"></span><br><span class="line">RectF rect = <span class="keyword">new</span> RectF();</span><br><span class="line">rect.left = <span class="number">100</span>;</span><br><span class="line">rect.top = <span class="number">100</span>;</span><br><span class="line">rect.right = <span class="number">600</span>;</span><br><span class="line">rect.bottom = <span class="number">400</span>;</span><br><span class="line">canvas.drawOval(rect,paint);</span><br></pre></td></tr></table></figure><p><strong>9. 画线条</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bc90069a3.jpg" alt="Alt text"></p><blockquote><p><strong>pts：</strong>坐标数组<br><strong>offset：</strong>跳过数组中前面几个数，才开始计算直线的坐标<br><strong>count：</strong>一起要多少个数组中的数来进行直线坐标的绘制，两个数算作一个点，直线需要两个点，也就是四个数构成一条直线，越界会出现异常，少于四个数不算作一条直线<br><strong>drawLines(float[] pts, int offset, int count, Paint paint)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> canvas.drawLine(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">100</span>,paint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画一个线条组成的正方形</span></span><br><span class="line"><span class="keyword">float</span>[] lines = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">canvas.drawLines(lines,paint);</span><br></pre></td></tr></table></figure><p><strong>10. 扇形</strong><br><img src="https://i.loli.net/2019/04/14/5cb2cbd3dadc7.jpg" alt="Alt text"></p><blockquote><p><strong>oval：</strong>矩形<br><strong>startAngle：</strong>扇形从哪个角度开始(顺时针0-360)<br><strong>sweepAngle：</strong>扇形整个展开的角度<br><strong>useCenter：</strong>是否连接到圆形，连接就是扇形，不连接就是弧形</p><p><strong>drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</strong></p><p><strong>left、top、right、bottom：</strong>矩形的左上角、右下角的坐标，因为弧形、扇形、圆形都可以是一个矩形内来规划。<br><strong>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RectF rect = <span class="keyword">new</span> RectF();</span><br><span class="line">rect.left = <span class="number">50</span>;</span><br><span class="line">rect.top = <span class="number">50</span>;</span><br><span class="line">rect.right = <span class="number">500</span>;</span><br><span class="line">rect.bottom = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//扇形</span></span><br><span class="line">canvas.drawArc(rect,<span class="number">0</span>,<span class="number">90</span>,<span class="keyword">true</span>,paint);</span><br><span class="line"><span class="comment">//弧形</span></span><br><span class="line">canvas.drawArc(rect,<span class="number">120</span>,<span class="number">90</span>,<span class="keyword">false</span>,paint);</span><br><span class="line"><span class="comment">//弧线</span></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">canvas.drawArc(rect,<span class="number">230</span>,<span class="number">90</span>,<span class="keyword">false</span>,paint);</span><br></pre></td></tr></table></figure><p><strong>11. 根据path路径绘制图形，更多的是不规则图形</strong></p><table><thead><tr><th style="text-align:left">Path常用方法</th><th style="text-align:left">效果、作用描述</th></tr></thead><tbody><tr><td style="text-align:left">lineTo(x,y)</td><td style="text-align:left">若起点为a(10,10),表示将线条从a绘制到终点坐标(x,y)</td></tr><tr><td style="text-align:left">rLineTo(dx,dy)</td><td style="text-align:left">若起点为a(10,10),表示将线条从a绘制到终点坐标(10+dx,10+dy)</td></tr><tr><td style="text-align:left">moveTo(x,y)</td><td style="text-align:left">将下一次path绘制的起点坐标移动至(x,y)，比如原本起点在a(10,10)，使用moveTo之后，下次的起点在(x,y)</td></tr><tr><td style="text-align:left">rMoveTo(dx,dy)</td><td style="text-align:left">将下一次path绘制的起点坐标增加dx、dy，比如原本起点在a(10,10)，使用rMoveTo之后，下次的起点在(10+dx,10+dy)</td></tr><tr><td style="text-align:left">setLastPoint(dx,dy)</td><td style="text-align:left">改变前一步path绘制的终点坐标,将终点从(x,y)改变为(dx，dy)</td></tr><tr><td style="text-align:left">addRect</td><td style="text-align:left">绘制矩形</td></tr><tr><td style="text-align:left">addRoundRect</td><td style="text-align:left">绘制圆角矩形</td></tr><tr><td style="text-align:left">addCircle</td><td style="text-align:left">　绘制圆形</td></tr><tr><td style="text-align:left">addOval</td><td style="text-align:left">绘制椭圆</td></tr><tr><td style="text-align:left">addArc、arcTo</td><td style="text-align:left">绘制圆弧</td></tr><tr><td style="text-align:left">close</td><td style="text-align:left">将path的起点和终点进行闭合</td></tr><tr><td style="text-align:left">Path.Direction.CW</td><td style="text-align:left">顺时针、clockwise</td></tr><tr><td style="text-align:left">Path.Direction.CCW</td><td style="text-align:left">逆时针、counter-clockwise</td></tr></tbody></table><ul><li><strong>lineTo和rLineTo</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bd92f27ed.jpg" alt="Alt text"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lineTo和rLineTo</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">Path path2 = <span class="keyword">new</span> Path();</span><br><span class="line">path2.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path2.rLineTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">canvas.drawPath(path2, paint);</span><br></pre></td></tr></table></figure><ul><li><strong>rMoveTo和moveTo</strong><br><img src="https://i.loli.net/2019/04/14/5cb2c0c5422b8.jpg" alt="Alt text"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rMoveTo和moveTo</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.rMoveTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">path.lineTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">Path path2 = <span class="keyword">new</span> Path();</span><br><span class="line">path2.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path2.moveTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">path2.lineTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">canvas.drawPath(path2, paint);</span><br></pre></td></tr></table></figure><ul><li><p><strong>addRect、addRoundRect、addCircle、addOval</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bd935bb05.jpg" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加圆形</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.setFillType(Path.FillType.WINDING);</span><br><span class="line">path.addCircle(<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>,Path.Direction.CW);</span><br><span class="line">path.addCircle(<span class="number">500</span>,<span class="number">300</span>,<span class="number">200</span>,Path.Direction.CW);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure></li><li><p><strong>addArc、arcTo</strong><br>都是绘制圆弧的，addArc与arcTo的区别简单来说在于：参数forceMoveTo，是否强制将path的最后一个点移动到圆弧的起点，true表示强制移动，不连接两点，false表示连接两点。addArc相当于默认是true，不连接两点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制圆弧</span></span><br><span class="line">addArc(RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle)</span><br><span class="line">addArc(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle,<span class="keyword">float</span> sweepAngle)</span><br><span class="line"></span><br><span class="line"><span class="comment">//forceMoveTo：是否强制将path最后一个点移动到圆弧起点，</span></span><br><span class="line"><span class="comment">//true是强制移动，即为不连接两个点；false则连接两个点</span></span><br><span class="line">arcTo(RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle,<span class="keyword">boolean</span> forceMoveTo)</span><br><span class="line">arcTo(RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle)</span><br><span class="line">arcTo(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle,<span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> forceMoveTo)</span><br></pre></td></tr></table></figure><ul><li><strong>arcTo绘制连接和不连接的两条路径</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bd935d391.jpg" alt="Alt text"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//黄色线条，与圆弧不连接</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">path.arcTo(<span class="number">300</span>,<span class="number">200</span>,<span class="number">600</span>,<span class="number">500</span>,-<span class="number">90</span>,<span class="number">180</span>,<span class="keyword">true</span>);</span><br><span class="line">canvas.drawPath(path,paint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//红色线条，与圆弧连接</span></span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">Path path2 = <span class="keyword">new</span> Path();</span><br><span class="line">path2.lineTo(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">path2.arcTo(<span class="number">200</span>,<span class="number">200</span>,<span class="number">550</span>,<span class="number">500</span>,-<span class="number">90</span>,<span class="number">180</span>,<span class="keyword">false</span>);</span><br><span class="line">canvas.drawPath(path2,paint);</span><br></pre></td></tr></table></figure><ul><li><strong>使用Path绘制爱心</strong><br><img src="https://i.loli.net/2019/04/14/5cb2c122c72b4.jpg" alt="Alt text"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据path路径绘制一个爱心</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.addArc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">225</span>, <span class="number">225</span>);</span><br><span class="line">path.arcTo(<span class="number">400</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">400</span>, -<span class="number">180</span>, <span class="number">225</span>, <span class="keyword">false</span>);</span><br><span class="line">path.lineTo(<span class="number">400</span>, <span class="number">542</span>);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure><p><strong>12. Path.setFillType(Path.FillType ft) 设置填充方式</strong></p><ul><li>EVEN_ODD(交叉填充)</li><li>WINDING （默认值，全部填充）</li><li>INVERSE_EVEN_ODD(反向交叉填充)</li><li>INVERSE_WINDING(反向全部填充)<br><img src="https://i.loli.net/2019/04/14/5cb2beeb5f45f.jpg" alt="Alt text"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完全填充</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line"><span class="comment">//绘制区域全部填充</span></span><br><span class="line">path.setFillType(Path.FillType.WINDING);</span><br><span class="line"><span class="comment">//绘制区域重合处不填充</span></span><br><span class="line">path.setFillType(Path.FillType.EVEN_ODD);</span><br><span class="line"><span class="comment">//绘制区域外全部填充</span></span><br><span class="line">path.setFillType(Path.FillType.INVERSE_WINDING);</span><br><span class="line"><span class="comment">//绘制区域重合出填充，绘制区域外全部填充</span></span><br><span class="line">path.setFillType(Path.FillType.INVERSE_EVEN_ODD);</span><br><span class="line">path.addCircle(<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>,Path.Direction.CW);</span><br><span class="line">path.addCircle(<span class="number">500</span>,<span class="number">300</span>,<span class="number">200</span>,Path.Direction.CW);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure><ul><li><strong>效果展示图</strong></li></ul><p><img src="https://i.loli.net/2019/04/14/5cb2bd936f0d1.jpg" alt="Alt text"><br><img src="https://i.loli.net/2019/04/14/5cb2bd937980e.jpg" alt="Alt text"></p><ul><li><strong>反向，不在绘制区域内的部分，也会被填充颜色</strong><br><img src="https://i.loli.net/2019/04/14/5cb2bf12554e2.jpg" alt="Alt text"><br><img src="https://i.loli.net/2019/04/14/5cb2bf125eeb5.jpg" alt="Alt text"></li></ul><hr><p><strong>PDF文件获取地址 : </strong><br><a href="https://pan.baidu.com/s/1v2BNdBQfwp7dBrPHykduKQ" target="_blank" rel="noopener">2. 自定义View方法查询手册-Canvas 百度云</a>  提取码：tkhi</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义View方法查询手册-Paint</title>
      <link href="/2019/03/07/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Paint/"/>
      <url>/2019/03/07/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Paint/</url>
      
        <content type="html"><![CDATA[<p><strong>系列文章</strong></p><p><a href="https://www.syncxiao.com/2019/03/07/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Paint">1. 自定义View方法查询手册-Paint</a></p><p><a href="https://www.syncxiao.com/2019/04/14/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C-Canvas">2. 自定义View方法查询手册-Canvas</a></p><hr><a id="more"></a><hr><h2 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1. 基本设置"></a>1. 基本设置</h2><ul><li><strong>为了方便展示，后续操作均基于以下代码进行修改。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HenView6</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mZHText = <span class="string">"自定义View方法查询手册"</span>;</span><br><span class="line"></span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">    Path patn = <span class="keyword">new</span> Path();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HenView6</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//设置文字大小</span></span><br><span class="line">        paint.setTextSize(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//设置线条宽度</span></span><br><span class="line">        paint.setStrokeWidth(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HenView6</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//绘制文字</span></span><br><span class="line">        canvas.drawText(mZHText,<span class="number">200</span>,<span class="number">200</span>,paint);</span><br><span class="line">        <span class="comment">//绘制一个圆</span></span><br><span class="line">        canvas.drawCircle(<span class="number">500</span>,<span class="number">600</span>,<span class="number">200</span>,paint);</span><br><span class="line">        <span class="comment">//绘制一条线段</span></span><br><span class="line">        canvas.drawLine(<span class="number">100</span>,<span class="number">300</span>,<span class="number">1000</span>,<span class="number">300</span>,paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>原始效果展示</strong></li></ul><p><img src="https://i.loli.net/2019/02/28/5c7766301b3e5.jpg" alt="image|center|500x0"></p><hr><h2 id="2-画笔Paint"><a href="#2-画笔Paint" class="headerlink" title="2. 画笔Paint"></a>2. 画笔Paint</h2><table><thead><tr><th>方法原型</th><th>方法调用</th><th style="text-align:center">效果展示</th></tr></thead><tbody><tr><td>设置透明度和颜色a表示透明度，取值从0-255，从完全透明-不透明.<br><strong>setARGB(int a, int r, int g, int b)</strong></td><td>设置透明度为100，颜色为浅水红 <br>paint.setARGB(100,200,0,0)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c777fb0cd291.jpg" alt="image"></td></tr><tr><td>单独设置颜色<br><strong>setColor(int color)</strong></td><td><code>//方式一</code><br>paint.setColor(Color.parseColor(“#889988”))<br><code>//方式二</code><br>paint.setColor(Color.GREEN)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77661fe06f9.jpg" alt="image"></td></tr><tr><td>单独设置透明度<br><strong>setAlpha(int a)</strong></td><td>设置透明度为100<br>paint.setAlpha(100)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c777d2d37b20.jpg" alt="image"></td></tr><tr><td>设置文本之间的间距默认值是0，大于0宽松，小于0收紧<br><strong>setLetterSpacing(float letterSpacing)</strong></td><td>设置文本之间的间距为0.05<br>paint.setLetterSpacing(0.5f)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c777d4913ff6.jpg" alt="image"></td></tr><tr><td>设置文本对齐方式即文本在原点的左侧、中间、右侧<br><strong>setTextAlign(Paint.Align align)</strong></td><td><code>//左对齐</code><br>paint.setTextAlign(Paint.Align.LEFT)<br><code>//居中对齐</code><br>paint.setTextAlign(Paint.Align.CENTER)<br><code>//右对齐</code><br>paint.setTextAlign(Paint.Align.RIGHT)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77b316335a0.jpg" alt="image"></td></tr><tr><td>设置文本区域列表其实就是根据设置的区域显示文本<br><strong>setTextLocale(Locale locale)</strong></td><td>mZHText = “雨水”<br><code>//区域默认是中国</code><br>canvas.drawText(mZHText,200,200,paint)<br><code>//区域设置为中国台湾</code><br>paint.setTextLocale(Locale.TAIWAN)<br>canvas.drawText(mZHText,600,200,paint)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77b417aa487.jpg" alt="image"></td></tr><tr><td>设置文本横向缩放默认值是1，大于1放宽，小于1锁紧<br><strong>setTextScaleX(float scaleX)</strong></td><td>缩放0.5<br>paint.setTextScaleX(0.5f)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c777ebf4f156.jpg" alt="image"></td></tr><tr><td>设置字体类型<br><strong>setTypeface(Typeface typeface)</strong></td><td>设置为黑体<br>paint.setTypeface(Typeface.DEFAULT_BOLD)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c777ecd5512c.jpg" alt="image"></td></tr><tr><td>设置字体类型<br><strong>setTypeface(Typeface typeface)</strong></td><td>设置为Serif斜体<br>Typeface typeface = Typeface.create<br>(Typeface.SERIF,Typeface.BOLD_ITALIC)<br>paint.setTypeface(typeface)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c777ed91d6c8.jpg" alt="image"></td></tr><tr><td>设置抗锯齿，默认是关闭的<br><strong>setAntiAlias (boolean aa)</strong></td><td>开启抗锯齿，注意放大图片观察边缘效果<br>paint.setAntiAlias(true)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77ac7a9d45f.jpg" alt="image"></td></tr><tr><td>设置绘制模式默认是FILL填充模式，另外还有STROKE画线模式、FILL_AND_STROKE填充画线<br><strong>setStyle(Paint.Style style)</strong></td><td>设置为画线模式<br>paint.setStyle(Paint.Style.STROKE)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77ac9154f10.jpg" alt="image"></td></tr><tr><td>设置线条宽度<br><strong>setStrokeWidth(float width)</strong></td><td>设置线条宽度为30<br>paint.setStrokeWidth(30)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77aca9c896e.jpg" alt="image"></td></tr><tr><td>设置线头形状有三种：默认BUTT 平头、ROUND 圆头、SQUARE 方头<br><strong>setStrokeCap(Paint.Cap cap)</strong></td><td>默认平头<br>paint.setStrokeCap(Paint.Cap.BUTT)<br>圆头<br>paint.setStrokeCap(Paint.Cap.ROUND)<br>方头<br>paint.setStrokeCap(Paint.Cap.SQUARE)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77acb6c64dc.jpg" alt="image"></td></tr><tr><td>设置拐角形状有三种：默认MITER 尖角、BEVEL 平角、ROUND 圆角<br><strong>setStrokeJoin(Paint.Join join)</strong></td><td>尖角<br>paint.setStrokeJoin(Paint.Join.MITER)<br>平角paint.setStrokeJoin(Paint.Join.BEVEL)<br>圆角<br>paint.setStrokeJoin(Paint.Join.ROUND)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77acc154206.jpg" alt="image"></td></tr><tr><td>设置MITER型拐角的延长线的最大值其实就是尖的拐角在超过最大值时，会变成BEVEL型平角，默认值是4,拐角大约是29°的锐角<br><strong>setStrokeMiter(float miter)</strong></td><td>设置默认值4<br>paint.setStrokeMiter(4)<br>修改最大值为2<br>paint.setStrokeMiter(2)<br>修改最大值为5<br>paint.setStrokeMiter(5)</td><td style="text-align:center"><img src="https://i.loli.net/2019/02/28/5c77accb20f0b.jpg" alt="image"></td></tr><tr><td><strong>着色器 Shader</strong></td><td><strong>paint.setShader(shader))</strong></td><td style="text-align:center"></td></tr><tr><td><strong>线性渐变LinearGradient</strong> <br>x0 y0 x1 y1：渐变的两个端点的位置 <br>color0 color1：是端点的颜色</td><td><strong>CLAMP模式</strong><br>Shader shader = <br>new LinearGradient(300, 200, 700, 600, <br>Color.parseColor(“#E91E63”), <br>Color.parseColor(“#2196F3”), <br>Shader.TileMode.CLAMP)</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105ae5c2ac.jpg" alt="16.jpg"></td></tr><tr><td></td><td><strong>REPEAT重复模式</strong><br>Shader shader = <br>new LinearGradient(300, 200, 700, 600, <br>Color.parseColor(“#E91E63”), <br>Color.parseColor(“#2196F3”), <br>Shader.TileMode.REPEAT)</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105f4482bd.jpg" alt="17.jpg"></td></tr><tr><td></td><td><strong>MIRROR镜像模式</strong><br>Shader shader = <br>new LinearGradient(300, 200, 700, 600, <br>Color.parseColor(“#E91E63”), <br>Color.parseColor(“#2196F3”), <br>Shader.TileMode.MIRROR)</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105f445367.jpg" alt="18.jpg"></td></tr><tr><td><strong>辐射渐变RadialGradient</strong><br>centerX centerY：辐射中心的坐标 <br>radius：辐射半径 <br>centerColor：辐射中心的颜色 <br>edgeColor：辐射边缘的颜色</td><td><strong>CLAMP模式</strong><br>Shader shader = <br>new RadialGradient(500, 420, 100, <br>Color.parseColor(“#E91E63”), <br>Color.parseColor(“#2196F3”), <br>Shader.TileMode.CLAMP);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105f4613db.jpg" alt="19.jpg"></td></tr><tr><td></td><td><strong>REPEAT重复模式</strong><br>Shader shader = <br>new RadialGradient(500, 420, 100, <br>Color.parseColor(“#E91E63”), <br>Color.parseColor(“#2196F3”), <br>Shader.TileMode.REPEAT);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105f466f1c.jpg" alt="20.jpg"></td></tr><tr><td></td><td><strong>MIRROR镜像模式</strong><br>Shader shader = <br>new RadialGradient(500, 420, 100, <br>Color.parseColor(“#E91E63”), <br>Color.parseColor(“#2196F3”), <br>Shader.TileMode.MIRROR);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105f46a81a.jpg" alt="21.jpg"></td></tr><tr><td><strong>扫描渐变SweepGradient</strong><br>cx cy ：扫描的中心 <br>color0：扫描的起始颜色 <br>color1：扫描的终止颜色</td><td>Shader shader = <br>new SweepGradient(500,420,<br>Color.parseColor(“#E91E63”),<br>Color.parseColor(“#2196F3”));</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8105f468c76.jpg" alt="22.jpg"></td></tr><tr><td><strong>BitmapShader 使用bitmap的像素来作为图片或文字的填充</strong><br>bitmap：用来做模板的Bitmap对象 <br>tileX：横向的 TileMode <br>tileY：纵向的 TileMode</td><td><strong>CLAMP模式</strong><br>Shader shader = new BitmapShader(bitmap,<br>Shader.TileMode.REPEAT,Shader.TileMode.CLAMP);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106852ddf5.jpg" alt="23.jpg"></td></tr><tr><td></td><td><strong>REPEAT重复模式</strong><br>Shader shader = new BitmapShader(bitmap,<br>Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106855ab95.jpg" alt="25.jpg"></td></tr><tr><td></td><td><strong>MIRROR镜像模式</strong><br>Shader shader = new BitmapShader(bitmap,<br>Shader.TileMode.REPEAT,Shader.TileMode.MIRROR);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c81068544d16.jpg" alt="24.jpg"></td></tr><tr><td><strong>混合着色器ComposeShader</strong><br><strong><code>具体请关注下面关于PorterDuff.Mode的介绍</code></strong></td><td><code>//ShaderA</code><br>Shader shaderA = new BitmapShader<br>(bitmapA,Shader.TileMode.REPEAT,<br>Shader.TileMode.CLAMP);<br><code>//ShaderB</code><br>Shader shaderB = new BitmapShader<br>(bitmapB,Shader.TileMode.REPEAT,<br>Shader.TileMode.CLAMP);<br><code>//混合</code><br>Shader shader = new ComposeShader<br>(shaderA,shaderB,PorterDuff.Mode.SRC_OVER);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f4a2e2cf4d.jpg" alt="image"></td></tr><tr><td><strong>颜色过滤ColorFilter</strong></td><td><strong>paint.setColorFilter(colorFilter)</strong></td><td style="text-align:center"></td></tr><tr><td><strong>模拟光照效果<br>LightingColorFilter</strong></td><td><strong>原样绘制</strong><br>LightingColorFilter colorFilter = <br>new LightingColorFilter<br>(Color.parseColor(“#FFFFFF”),<br>Color.parseColor(“#000000”));</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f4c33b9c14.jpg" alt="image"></td></tr><tr><td></td><td><strong>加深红色</strong><br>LightingColorFilter colorFilter = <br>new LightingColorFilter<br>(Color.parseColor(“#FFFFFF”),<br>Color.parseColor(“#FF2222”));</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f4c40c7ab5.jpg" alt="image"></td></tr><tr><td></td><td><strong>加深绿色</strong><br>LightingColorFilter colorFilter = <br>new LightingColorFilter<br>(Color.parseColor(“#FFFFFF”),<br>Color.parseColor(“#22FF22”));</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f4c4a7676f.jpg" alt="image"></td></tr><tr><td></td><td><strong>加深蓝色</strong><br>LightingColorFilter colorFilter = <br>new LightingColorFilter<br>(Color.parseColor(“#FFFFFF”),<br>Color.parseColor(“#2222FF”));</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f4c542880f.jpg" alt="image"></td></tr><tr><td>使用指定颜色和Mode与绘制对象进行合成<br><strong>PorterDuffColorFilter</strong><br><strong><code>具体请关注下面关于PorterDuff.Mode的介绍</code></strong></td><td><strong>合成效果：灰色+圆形空缺</strong><br>PorterDuffColorFilter colorFilter = <br>new PorterDuffColorFilter<br>(Color.parseColor(“#666666”),<br>PorterDuff.Mode.SRC_OUT);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f4c5e9064f.jpg" alt="image"></td></tr><tr><td>使用ColorMatrix对颜色进行处理<br><strong>ColorMatrixColorFilter</strong></td><td><strong>ColorMatrix是一个4x5的矩阵，<br>通过计算把需要绘制的像素进行转换.<br>其中矩阵中的a、b、c、d四列用于改变颜色配色，<br>e所在列用于改变颜色深浅.</strong></td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f6c54e89e8.jpg" alt="5c7f6c54e89e8"></td></tr><tr><td></td><td><strong>滑动SeekBar，获取数值，改变红色</strong> <br><code>//定义数组</code><br>float colorArrays[] = new float[]<br>{red, 0, 0, 0, 0,<br>0, green, 0, 0, 0,<br>0, 0, blue, 0, 0,<br>0, 0, 0, alpha, 0}; <br><code>//创建颜色矩阵</code><br>ColorMatrix colorMatrix = new ColorMatrix(colorArrays);<br><code>//创建颜色过滤器</code><br>ColorMatrixColorFilter colorFilter = <br>new ColorMatrixColorFilter(colorMatrix);<br><code>//设置颜色过滤器</code><br>paint.setColorFilter(colorFilter);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f6df57a398.jpg" alt="image"></td></tr><tr><td></td><td><strong>滑动SeekBar，获取数值，改变绿色，代码同上</strong></td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f6e03718e2.jpg" alt="image"></td></tr><tr><td></td><td><strong>滑动SeekBar，获取数值，改变蓝色，代码同上</strong></td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f6e0fc7cbb.jpg" alt="image"></td></tr><tr><td></td><td><strong>滑动SeekBar，获取数值，改变透明度，代码同上</strong></td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f6e1a7db04.jpg" alt="image"></td></tr><tr><td><strong>修改色调 <br>colorMatrix.setRotate(int axis, float degrees)</strong> <br>第一个参数axis可以使用0、1、2分别表示修改红、绿、蓝色</td><td><strong>修改绿色色调</strong><br>colorMatrix.setRotate(1,100);<br>ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);<br>paint.setColorFilter(colorFilter);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f7a0dc0ff3.jpg" alt="image"></td></tr><tr><td><strong>修改亮度 <br>colorMatrix.setScale(float rScale, float gScale, float bScale, float aScale)</strong><br>当亮度按照相同比例修改，图像会变白，如果亮度为0，图像会变黑</td><td><strong>修改亮度</strong><br>colorMatrix.setScale(5,9,8,1);<br>ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);<br>paint.setColorFilter(colorFilter);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f7a199aab3.jpg" alt="image"></td></tr><tr><td><strong>修改饱和度，默认值1<br>colorMatrix.setSaturation(float sat)</strong><br>当饱和度为0，图片变成灰色</td><td><strong>饱和度修改为5<br></strong>colorMatrix.setSaturation(5);<br>ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);<br>paint.setColorFilter(colorFilter);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f7a238c078.jpg" alt="image"></td></tr><tr><td><strong>多个矩阵作用在一起，形成叠加效果</strong></td><td><strong>叠加效果</strong><br>ColorMatrix mMatrix=new ColorMatrix();<br><code>//合并已有的颜色矩阵</code><br>mMatrix.postConcat(colorMatrix);<br>mMatrix.postConcat(colorMatrix2);<br>mMatrix.postConcat(colorMatrix3);<br><code>//添加至颜色过滤器</code><br>ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(mMatrix);<br><code>//设置颜色过滤器</code><br>paint.setColorFilter(colorFilter);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/06/5c7f7a2d04f68.jpg" alt="image"></td></tr><tr><td><strong>Transfer mode 图像传输模式</strong><br>1.以绘制内容作为源图像;<br>2.以View中已有内容作为目标图像;<br>3.以PorterDuff.Mode作为绘制内容的颜色处理方案.</td><td><strong>paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC))</strong></td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8107971a84f.jpg" alt="42.jpg"></td></tr><tr><td><strong><code>未开启Off-screen Buffer，绘制出现黑色</code></strong></td><td><strong>注意使用离屏缓冲(Off-screen Buffer),否则绘制会出现黑色</strong><br>canvas.drawBitmap(bitmap1, 0, 0, paint);<br>paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));<br>canvas.drawBitmap(bitmap2, 0, 0, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c81079724974.jpg" alt="40.jpg"></td></tr><tr><td><strong><code>开启Off-screen Buffer，绘制正常</code></strong></td><td><code>//使用saveLayer开启Off-screen Buffer</code><br>int saved = canvas.saveLayer<br>(null,null,Canvas.CLIP_SAVE_FLAG);<br><code>//目标图像</code><br>canvas.drawBitmap(bitmap1, 0, 0, paint);<br><code>//设置Mode.SRC</code><br>paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));<br><code>//源图像</code><br>canvas.drawBitmap(bitmap2, 0, 0, paint);<br><code>//清除Mode</code><br>paint.setXfermode(null);<br><code>//恢复Off-screen Buffer</code><br>canvas.restoreToCount(saved);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8107972b89c.jpg" alt="41.jpg"></td></tr><tr><td><strong>给图形轮廓设置效果 PathEffect </strong></td><td><strong>paint.setPathEffect(PathEffect effect)</strong></td><td style="text-align:center"></td></tr><tr><td>把所有拐角变成圆角<br><strong>CornerPathEffect(float radius)</strong></td><td><code>//参数表示圆角半径</code><br>PathEffect pathEffect= new CornerPathEffect(20);<br>paint.setPathEffect(pathEffect);<br>canvas.drawPath(path, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d2ab5c8.jpg" alt="43.jpg"></td></tr><tr><td>把线条进行随机偏离，使用短线段进行拼接<br><strong>DiscretePathEffect(float segmentLength, float deviation)</strong></td><td><code>//参数分别表示拼接线段的长度、偏移量</code><br>PathEffect pathEffect = new DiscretePathEffect(20, 5);<br><br>paint.setPathEffect(pathEffect);<br>canvas.drawPath(path, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d2c16ae.jpg" alt="44.jpg"></td></tr><tr><td>使用虚线来绘制线条<br><strong>DashPathEffect(float[] intervals, float phase)</strong></td><td><code>//第一个参数是个数组，表示参数格式，必须是偶数，按照[画线长度、空白长度、画线长度、空白长度]排列；第二个参数表示偏移量</code><br>PathEffect pathEffect = new DashPathEffect(new float[]{20, 10, 5, 10}, 0);<br>paint.setPathEffect(pathEffect);<br>canvas.drawPath(path, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d2cb9f7.jpg" alt="45.jpg"></td></tr><tr><td>使用path来绘制虚线<br><strong>PathDashPathEffect(Path shape, float advance, float phase, PathDashPathEffect.Style style)</strong></td><td><code>//shape是用来绘制的path，advance是相邻shape之间的间隔，phase是偏移量，style有TRANSLATE(位移)、ROTATE(旋转)、MORPH(变体)三种</code><br>PathEffect pathEffect = new PathDashPathEffect(path, 50, 0, PathDashPathEffect.Style.MORPH);<br>paint.setPathEffect(pathEffect);<br>canvas.drawPath(path, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d2de6eb.jpg" alt="46.jpg"></td></tr><tr><td>组合效果，按照不同的PathEffect对目标进行绘制<br><strong>SumPathEffect(PathEffect first, PathEffect second)</strong></td><td><code>//参数表示不同的效果，不分先后</code><br>PathEffect pathEffect = new SumPathEffect(effect1, effect2);<br>paint.setPathEffect(pathEffect);<br>canvas.drawPath(path, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d2e7a47.jpg" alt="47.jpg"></td></tr><tr><td>组合效果，先对目标A使用一个PathEffect，目标A变化成目标B，然后再对目标B使用另一个PathEffect<br><strong>ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</strong></td><td><code>//outerpe是后应用的，innerpe是先应用的</code><br>PathEffect pathEffect = new ComposePathEffect(effect1, effect2);<br>paint.setPathEffect(pathEffect);<br>canvas.drawPath(path, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d2f159b.jpg" alt="48.jpg"></td></tr><tr><td>在绘制内容下面增加阴影效果<br><strong>setShadowLayer(float radius, float dx, float dy, int shadowColor)</strong></td><td><code>//参数分别表示阴影模糊范围，x、y方向的阴影偏移量，颜色</code><br>paint.setShadowLayer(10, 5, 5, Color.RED);<br>canvas.drawText(“Hello HenCoder”, 50, 200, paint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d339f7e.jpg" alt="49.jpg"></td></tr><tr><td><strong>在绘制内容上面增加附加效果<br>setMaskFilter(MaskFiltermaskfilter)</strong></td><td><strong>paint.setMaskFilter(maskFilter)</strong></td><td style="text-align:center"></td></tr><tr><td><strong>模糊效果 <br>BlurMaskFilter(float radius, Blur style)</strong><br>radius：表示阴影范围<br>style：表示类型</td><td><code>/NORMAL 内外都模糊绘制/</code><br>MaskFilter maskFilter1 = new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL);<br><code>/INNER 内部模糊，外部不绘制/</code><br>MaskFilter maskFilter2 = new BlurMaskFilter(50, BlurMaskFilter.Blur.INNER);<br><code>/OUTER 内部不绘制，外部模糊/</code><br>MaskFilter maskFilter3 = new BlurMaskFilter(50, BlurMaskFilter.Blur.OUTER);<br><code>/SOLID 内部正常绘制，外部模糊/</code><br>MaskFilter maskFilter4 = new BlurMaskFilter(50, BlurMaskFilter.Blur.SOLID);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d363c99.jpg" alt="50.jpg"></td></tr><tr><td><strong>获取绘制的Path<br>getFillPath(Path src, Path dst)</strong><br>src：表示绘制图形的原Path<br>dst：表示绘制的实际的Path</td><td>右图表示原Path和实际Path的区别，默认情况下原Path和实际Path是一样的，但是如果线条宽度不为0，或者设置了PathEffect，就会存在不同。</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c81076c6a814.jpg" alt="52.jpg"></td></tr><tr><td><strong>获取绘制文本的Path<br>getTextPath(char[] text, int index, int count,float x, float y, Path path)</strong></td><td></td><td style="text-align:center"></td></tr><tr><td><strong>获取绘制文本的Path<br>getTextPath(String text, int start, int end, float x, float y, Path path)</strong><br>text：表示需要绘制的文字<br>start：表示从哪个位置开始获取Path<br>end：表示从哪个位置结束获取Path<br> x、y：分别表示绘制时文本原点的x坐标、y坐标<br>path：表示哪个path将获得get到的路径</td><td><code>//获取文本的Path</code><br>paint.getTextPath(text, 0, text.length(), 50, 400, textPath);<br><code>//获取文本的Path，长度减少5</code><br>paint.getTextPath(text, 0, text.length()-5, 50, 600, textPath2);<br><code>//绘制Path，注意不是绘制文本</code><br>canvas.drawPath(textPath, pathPaint);</td><td style="text-align:center"><img src="https://i.loli.net/2019/03/07/5c8106d341911.jpg" alt="51.jpg"></td></tr></tbody></table><hr><p><strong>PDF文件获取地址 : </strong><br><a href="https://pan.baidu.com/s/1lz5FuN0ne94fk30qzgJF_Q" target="_blank" rel="noopener">1. 自定义View方法查询手册-Paint 百度云</a>  提取码：4uh7</p><p><a href="https://i.loli.net/2019/03/07/5c81143ee73b2.jpg" target="_blank" rel="noopener">2. 自定义View方法查询手册-Paint 微信扫一扫</a><br><img src="https://i.loli.net/2019/03/07/5c81143ee73b2.jpg" alt="自定义View方法查询手册-Paint 微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识：SurfaceView</title>
      <link href="/2019/02/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9ASurfaceView/"/>
      <url>/2019/02/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9ASurfaceView/</url>
      
        <content type="html"><![CDATA[<h4 id="1-SurfaceView与View的区别"><a href="#1-SurfaceView与View的区别" class="headerlink" title="1. SurfaceView与View的区别"></a>1. SurfaceView与View的区别</h4><ul><li>View主要适用于主动更新的情况，而SurfaceView主要适用于被动更新，例如频繁的刷新。</li><li>View在主线程中对页面进行刷新，而SurfaceView通常会通过一个子线程来进行页面的刷新。</li><li>View在绘图时没有使用双缓冲机制，而SurfaceView在底层的实现机制中就已经实现了双缓冲机制。</li></ul><a id="more"></a><h4 id="2-什么是双缓冲机制？"><a href="#2-什么是双缓冲机制？" class="headerlink" title="2.什么是双缓冲机制？"></a>2.什么是双缓冲机制？</h4><p>双缓冲可以理解为有两个线程轮番去解析视频流的帧图像，当一个线程解析完帧图像后，把图像渲染到界面中，同时另一线程开始解析下一帧图像，使得两个线程轮番配合去解析视频流，以达到流畅播放的效果。</p><h4 id="3-SurfaceView模板使用"><a href="#3-SurfaceView模板使用" class="headerlink" title="3.SurfaceView模板使用"></a>3.SurfaceView模板使用</h4><p>通常我们使用SurfaceView时可以使用如下的模板进行扩充，重点是继承SurfaceView，实现SurfaceHolder.Callback和Runnable接口。</p><p>下面的LineSurfaceView实现了两种效果 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.exalple.wudu.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Path;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceHolder;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineSurfaceView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>,<span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder holder;</span><br><span class="line">    <span class="keyword">private</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDrawing;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Path path;</span><br><span class="line">    <span class="keyword">private</span> Paint paint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x ,y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineSurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineSurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineSurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        holder = getHolder();</span><br><span class="line">        holder.addCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        setFocusable(<span class="keyword">true</span>);</span><br><span class="line">        setFocusableInTouchMode(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setKeepScreenOn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        path = <span class="keyword">new</span> Path();</span><br><span class="line">        paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        paint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">        paint.setColor(Color.RED);</span><br><span class="line">        <span class="comment">//这个参数会控制画出的图形是不是线条还是扇形</span></span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder surfaceHolder)</span> </span>&#123;</span><br><span class="line">        isDrawing = <span class="keyword">true</span>;</span><br><span class="line">        path.moveTo(<span class="number">0</span>,<span class="number">400</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder surfaceHolder, <span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder surfaceHolder)</span> </span>&#123;</span><br><span class="line">        isDrawing = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (isDrawing)&#123;</span><br><span class="line">            <span class="comment">//绘画板</span></span><br><span class="line">            draw();</span><br><span class="line">            <span class="comment">//------放开这里的注释会自动绘制正弦函数</span></span><br><span class="line">            <span class="comment">//x +=1;</span></span><br><span class="line">            <span class="comment">//y = (int) (100 * Math.sin(x * 2 * Math.PI / 180) + 400);</span></span><br><span class="line">            <span class="comment">//path.lineTo(x,y);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//50-100:经验值，一般是最合适的</span></span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span> - (end - start));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> dy  = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction())&#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                path.moveTo(dx,dy);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                path.lineTo(dx,dy);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas = holder.lockCanvas();</span><br><span class="line">            canvas.drawColor(Color.WHITE);</span><br><span class="line">            canvas.drawPath(path,paint);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(canvas != <span class="keyword">null</span>)&#123;</span><br><span class="line">                holder.unlockCanvasAndPost(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>效果1：未放开run方法中的注释，实现的是画板效果，可以手动绘制内容。</p><p><img src="https://i.loli.net/2019/02/22/5c6fd0e6ee2d2.gif" alt="5c6fd0e6ee2d2"></p></li><li><p>效果2：放开run方法中的注释，实现的是自动绘制正弦函数的效果。</p><p><img src="https://i.loli.net/2019/02/22/5c6fd0fb2efbc.gif" alt="5c6fd0fb2efbc"></p></li></ul><h4 id="4-事件分发"><a href="#4-事件分发" class="headerlink" title="4.事件分发"></a>4.事件分发</h4><ul><li><p>onTouchEvent</p><blockquote><p>用来处理事件</p><p>返回true，表示该View可以处理好此事件，再向上传递，即不需要父类再来处理这个事件了。</p><p>返回false，表示该View不能处理该事件，需要传递给父类的onTouchEvent方法来处理。</p></blockquote></li><li><p>dispatchTouchEvent</p><blockquote><p>用来分派事件</p><p>其中调用了onInterceptTouchEvent和onTouchEvent方法，一般不重写该方法</p></blockquote></li><li><p>onInterceptTouchEvent</p><blockquote><p>用来拦截事件</p><p>ViewGroup类中的源码实现就是{return false;}表示不拦截该事件，事件将向下传递()传递给其子View)；</p><p>若手动重写该方法，使其返回true则表示拦截，事件将终止向下传递，事件由当前ViewGroup类来处理，就是调用该类的onTouchEvent()方法。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SurfaceView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识：TCP的三次握手和四次挥手</title>
      <link href="/2019/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9ATCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9ATCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-TCP三次握手过程分析"><a href="#1-TCP三次握手过程分析" class="headerlink" title="1. TCP三次握手过程分析"></a>1. TCP三次握手过程分析</h3><p>TCP(Transmission Control Protocol)即传输控制协议，是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p><a id="more"></a><p><strong>1. TCP报文首部</strong></p><ul><li><p>SYN (Synchronous 同步) </p><blockquote><p>在连接建立时用来同步序号，当SYN=1，ACK=0，表明是连接请求报文；若同意连接，则响应报文中应该是SYN=1，ACK=1。</p></blockquote></li><li><p>ACK (Acknowledgement 确认) </p><blockquote><p>表示确认接受，不管是三次握手还是四次分手，在回应的时候都会加上ACK=1，表示消息接收到了，并且在建立连接以后发送数据时，都需加上ACK=1，来表示数据接收成功，仅当ACK=1时，确认号字段才有效；ACK=0时，确认号无效。</p></blockquote></li><li><p>FIN (Finish 结束) </p><blockquote><p>表示请求关闭连接，当FIN=1，表明此报文发送方的数据已经发送完毕，并且要求释放。</p></blockquote></li><li><p>seq (sequence number 序列号) </p><blockquote><p>占4个字节，用来标记数据段的顺序。TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p></blockquote></li><li><p>ack (acknowledge number 确认号）</p><blockquote><p>占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p></blockquote></li></ul><p><strong>PS : ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</strong></p><p><strong>2. TCP连接的建立(三次握手)</strong></p><blockquote><p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p></blockquote><ul><li><strong>三次握手GIF图</strong></li></ul><p><img src="https://i.loli.net/2019/02/21/5c6e8f649e5f2.gif" alt="5c6e8f649e5f2"></p><ul><li><strong>握手过程</strong></li></ul><ol><li><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态。</p></li><li><p>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p></li><li><p>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中 SYN=1，ACK=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p></li><li><p>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p></li><li><p>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p></li></ol><ul><li><strong>三次握手过程图</strong></li></ul><p><img src="https://i.loli.net/2019/02/21/5c6e91f7c62b9.png" alt="5c6e91f7c62b9"></p><ul><li><strong>三次握手过程中seq、ack变化图</strong></li></ul><p><img src="https://i.loli.net/2019/02/21/5c6e921e1c846.png" alt="5c6e921e1c846"></p><p><strong>3. 为什么TCP客户端最后还要发送一次确认呢？</strong></p><blockquote><p><strong>一句话：主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p><pre><code>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</code></pre></blockquote><hr><h3 id="2-四次挥手过程分析"><a href="#2-四次挥手过程分析" class="headerlink" title="2. 四次挥手过程分析"></a>2. 四次挥手过程分析</h3><p><strong>1. TCP连接的断开(四次挥手)</strong></p><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote><ul><li><p><strong>四次挥手GIF图</strong></p><p><img src="https://i.loli.net/2019/02/21/5c6e9362c217f.gif" alt="5c6e9362c217f"></p></li><li><p><strong>挥手过程</strong></p></li></ul><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ol><ol start="2"><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li></ol><ol start="3"><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li></ol><ol start="4"><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li></ol><ol start="5"><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li></ol><ol start="6"><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><ul><li><p><strong>四次挥手过程图</strong></p><p><img src="https://i.loli.net/2019/02/21/5c6e93cb07ad4.png" alt="5c6e93cb07ad4"></p></li></ul><p><strong>2. 为什么客户端最后还要等待2MSL？</strong></p><blockquote><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的请求报文。</p></blockquote><p><strong>3. 为什么建立连接是三次握手，关闭连接却是四次挥手呢？</strong></p><blockquote><p> 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>而关闭连接的时候，服务器收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，而服务器也未必将全部数据都发送给客户端了，所以服务器会先发送一个ACK报文给客户端，告诉客户端“你发送的FIN报文我收到了”，等到服务器所有的报文都发送完毕，才会发送FIN报文给对客户端来表示同意现在关闭连接，所以需要四次挥手。</p></blockquote><p><strong>4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote><hr><p><strong>本文来源于以下文章:</strong></p><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP的三次握手与四次挥手（详解+动图）</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识: HTTPS</title>
      <link href="/2019/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AHTTPS/"/>
      <url>/2019/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AHTTPS/</url>
      
        <content type="html"><![CDATA[<p><strong>1. HTTPS简介</strong><br>HTTPS（Hypertext Transfer Protocol Secure)即超文本传输安全协议，是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><a id="more"></a><p><strong>2. HTTPS和HTTP的区别</strong> </p><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议。 </li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80端口，HTTPS是443端口。 </li><li>HTTP的连接很简单，是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。</li></ul><p><strong>3. HTTPS工作原理</strong></p><p><strong>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示 :</strong>　　</p><ol><li><p>客户使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></li><li><p>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。　　</p></li><li><p>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。　</p></li><li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。　　</p></li><li><p>Web服务器利用自己的私钥解密出会话密钥。　　</p></li><li><p>Web服务器利用会话密钥加密与客户端之间的通信。</p></li></ol><p><strong>HTTPS对应的通讯时序图：</strong></p><p><img src="https://i.loli.net/2019/02/21/5c6e808224b37.jpg" alt="5c6e808224b37"></p><p><strong>4. HTTPS的优点</strong>　　</p><ol><li><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：　　</p></li><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；　　</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。　　</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。　</p></li><li><p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高。</p></li></ol><p><strong>5. HTTPS的缺点</strong>　　</p><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：　　</p><ol><li><p>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；　　</p></li><li><p>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；　　</p></li><li><p>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。　   </p></li><li><p>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。　　</p></li><li><p>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识：HTTP</title>
      <link href="/2019/02/18/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AHTTP/"/>
      <url>/2019/02/18/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AHTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP简介"><a href="#1-HTTP简介" class="headerlink" title="1. HTTP简介"></a>1. HTTP简介</h2><ul><li>HTTP即超文本传输协议(Hyper Text Transfer Protocol)，是用于从万维网(www)服务器传输超文本到本地浏览器的一种传输协议。</li><li>基于TCP/IP通信协议来传递数据。</li><li>属于应用层的面向对象的协议。</li></ul><a id="more"></a><h2 id="2-HTTP的特点"><a href="#2-HTTP的特点" class="headerlink" title="2. HTTP的特点"></a>2. HTTP的特点</h2><ul><li><p><strong>简单快速：</strong>客户端向服务端请求时只需要传送请求方法和路径，常用的请求方法有GET、POST、HEAD，每种方法规定了客户端和服务器联系的类型不同，用户HTTP协议简单，使得HTTP服务器程序规模较小，因此通信速度很快。</p></li><li><p><strong>灵活：</strong>HTTP允许传输任意类型的数据对象，传输中数据类型通过Content-type标记。</p></li><li><p><strong>HTTP 0.9和1.0使用非持续连接：</strong>限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。<strong>HTTP 1.1使用持续连接：</strong>不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</p></li><li><p><strong>无状态：</strong>HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，但是同样也保证了服务器的内存，并且不会因为之前给它发送过应答报文而不接受第二次请求。</p></li></ul><h2 id="3-HTTP的请求方法"><a href="#3-HTTP的请求方法" class="headerlink" title="3. HTTP的请求方法"></a>3. HTTP的请求方法</h2><p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：</p><ul><li><p><strong>OPTIONS</strong> - 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p></li><li><p><strong>HEAD</strong>- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p></li><li><p><strong>GET</strong> - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p></li><li><p><strong>POST</strong> - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。</p></li><li><p><strong>PUT</strong> - 向指定资源位置上传其最新内容。</p></li><li><p><strong>DELETE</strong> - 请求服务器删除Request-URI所标识的资源。</p></li><li><p><strong>TRACE</strong>- 回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p><strong>CONNECT</strong> - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p></li><li><p><strong>PATCH</strong> - 用来将局部修改应用于某一资源，添加于规范RFC5789。</p></li></ul><p><strong>注意点：</strong> </p><ol><li>请求的方法名称是区分大小写的；</li><li>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）；</li><li>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。</li></ol><h2 id="4-HTTP的请求步骤"><a href="#4-HTTP的请求步骤" class="headerlink" title="4. HTTP的请求步骤"></a>4. HTTP的请求步骤</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><h4 id="1-HTTP-请求-响应的步骤"><a href="#1-HTTP-请求-响应的步骤" class="headerlink" title="1. HTTP 请求/响应的步骤"></a>1. HTTP 请求/响应的步骤</h4><p><strong>(1)、客户端连接到Web服务器</strong><br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，HTTP://<a href="http://www.oakcms.cn。" target="_blank" rel="noopener">www.oakcms.cn。</a></p><p><strong>(2)、发送HTTP请求</strong><br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p><strong>(3)、服务器接受请求并返回HTTP响应</strong><br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p><strong>(4)、释放连接TCP连接</strong><br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p><strong>(5)、客户端浏览器解析HTML内容</strong><br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p><strong>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</strong><br>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<br>6、浏览器将该 html 文本并显示内容;</p><h4 id="2-请求头与响应体"><a href="#2-请求头与响应体" class="headerlink" title="2. 请求头与响应体"></a>2. 请求头与响应体</h4><p><strong>(1)、GET请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---请求行</span></span><br><span class="line">GET /mHTTP/login/?name=hp HTTP/<span class="number">1.1</span>    <span class="comment">//请求方法  请求URL(客户端所说的接口) HTTP协议版本号</span></span><br><span class="line"><span class="comment">//---请求头</span></span><br><span class="line">Host: passport-api.sdk.mgame.com    <span class="comment">//请求的域名</span></span><br><span class="line">Content-Type: application/json        <span class="comment">//请求对象的类型</span></span><br><span class="line">Accept: application/json</span><br><span class="line">Authentication: Code xxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里一定也有一个空行</span></span><br></pre></td></tr></table></figure><p><strong>(2)、POST请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---请求行</span></span><br><span class="line">POST /mHTTP/auth/register HTTP/<span class="number">1.1</span>        <span class="comment">//请求方法  请求URL(客户端所说的接口) HTTP协议版本号</span></span><br><span class="line"><span class="comment">//---请求头</span></span><br><span class="line">Host: passport-api.sdk.game.com        <span class="comment">//请求的域名</span></span><br><span class="line">Content-Type: application/json        <span class="comment">//请求对象的类型</span></span><br><span class="line">Accept: application/json</span><br><span class="line"></span><br><span class="line"><span class="comment">//post请求这里一定有个空行</span></span><br><span class="line">channel_id=<span class="number">1</span>&amp;type=auth&amp;channel_login=<span class="number">1</span>        <span class="comment">//---请求数据</span></span><br></pre></td></tr></table></figure><p><strong>(3)、响应体</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态行</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="comment">//以下都是消息报头</span></span><br><span class="line">X-SDK-Server: passport-api</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息报头和响应正文(下方是响应正文)之间也一定有个空行</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"account"</span>: &#123;</span><br><span class="line">    <span class="string">"uid"</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="string">"account"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="string">"view_name"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"mobile"</span>:<span class="string">"13000000000"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应体图示</strong><br><img src="https://i.imgur.com/pzhNpxi.png" alt></p><h4 id="3-POST与GET的区别"><a href="#3-POST与GET的区别" class="headerlink" title="3. POST与GET的区别"></a>3. POST与GET的区别</h4><p><strong>(1). 请求参数</strong></p><ul><li><strong>GET提交时</strong>请求数据会附在URL之后(就是把数据放在HTTP协议头中)，并以?分割URL与数据，多个参数使用&amp;连接。 例如：login?name=hp&amp;passwoed=09987。如果数据是英文字母、数字则原样发送，如果是中文或其他字符，则把字符串用BASE64加密，得到如：%E4%BD%A0%E5%A5%BD的，其中％XX中的XX为该符号以16进制表示的ASCII。</li><li><strong>POST提交时</strong>提交数据会放在HTTP的包体中(比如上面的POST请求示例)。</li></ul><p><strong>(2). 传输数据的大小</strong><br><strong>首先明确的是：HTTP协议并没有对传输数据的大小进行限制，HTTP协议规范也没有对URL的长度进行限制。</strong><br>实际开发中的主要限制在于：</p><ul><li><strong>GET</strong>：特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。因此对于GET提交时，传输数据就会受到URL长度的 限制。</li><li><strong>POST</strong>：由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</li></ul><p><strong>(3). 安全性</strong><br><strong>POST的安全性要比GET的安全性高。</strong></p><ul><li>因为通过GET提交数据，用户名和密码将明文出现在URL上，然后登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了；</li><li>除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识: ClassLoader</title>
      <link href="/2019/02/15/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AClassLoader/"/>
      <url>/2019/02/15/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9AClassLoader/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ClassLoader的作用"><a href="#1-ClassLoader的作用" class="headerlink" title="1. ClassLoader的作用"></a>1. ClassLoader的作用</h2><p>我们编写好的Java程序都是由若干个.class文件组织而成，在启动程序运行的时候并不会一次性加载所有的class文件，而是根据程序的需要，通过Java的类加载机制(ClassLoader)动态的加载某些class文件到内存中，从而被其他class使用，所以<strong>ClassLoader就是用来动态加载class文件到内存中的.</strong></p><a id="more"></a><hr><h2 id="2-Java默认提供的三个ClassLoader"><a href="#2-Java默认提供的三个ClassLoader" class="headerlink" title="2. Java默认提供的三个ClassLoader"></a>2. Java默认提供的三个ClassLoader</h2><p><strong>(1). Bootstrap ClassLoader</strong><br><strong>启动类加载器</strong>，是Java最顶层的类加载器。主要负责加载JDK中的核心类库，如<strong>jdk_xxx/jre/lib/rt.jar，jdk_xxx/jre/lib/resources.jar，jdk_xxx/jre/lib/charsets.jar和class</strong>(还可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录，比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.从测试类中可以看到本机的加载路径</span></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;  </span><br><span class="line">    System.out.println(urls[i].toExternalForm());  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/resources.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/rt.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/sunrsasign.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/jsse.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/jce.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/charsets.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/lib/jfr.jar</span><br><span class="line">file:/E:/java_jdk_1.8/Java/jre.8.0_92/classes</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述的打印结果通过查询系统属性 sun.boot.class.path 也可以得知</span></span><br><span class="line">System.getProperty(<span class="string">"sun.boot.class.path"</span>)</span><br></pre></td></tr></table></figure><p><strong>(2). ExtClassLoader</strong><br><strong>扩展类加载器</strong>，负责加载Java的扩展类库，默认加载<strong>jdk_xxx/jre/lib/ext</strong>目录下的jar和class(还可以加载-D java.ext.dirs选项指定的目录).</p><p><strong>(3). AppClassLoader</strong><br><strong>系统类加载器</strong>，负责加载应用程序classpath目录下所有的jar和class.</p><p><strong>(4). 不同加载器之间的区别</strong></p><ol><li><p>除了Java默认提供的三个ClassLoader之外，用户还可以根据自身需要自定义ClassLoader，但是必须继承自<code>java.lang.ClassLoader，上面提到的ExtClassLoader和AppClassLoader也都是继承自java.lang.ClassLoader</code>;</p></li><li><p><code>Bootstrap ClassLoader并不是继承自java.lang.ClassLoader</code>，因为它并不是一个普通的Java类，而是有C++编写的底层类，并嵌入到JVM中，成为JVM的一部分，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器;</p></li><li><p>以上三个ClassLoader的加载顺序为：<code>Bootstrap ClassLoader --&gt; ExtClassLoader --&gt; AppClassLoader</code>.</p></li></ol><p><strong>(5). 源码解析</strong></p><ul><li><p><strong>1. sun.misc.Launcher : Java虚拟机的入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"><span class="comment">//Launcher的构造方法(精简之后的)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ExtClassLoader localExtClassLoader;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      localExtClassLoader = ExtClassLoader.getExtClassLoader();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException localIOException1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>,</span><br><span class="line">              localIOException1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loader = AppClassLoader.getAppClassLoader(localExtClassLoader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException localIOException2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">              <span class="string">"Could not create application class loader"</span>,</span><br><span class="line">              localIOException2);</span><br><span class="line">  &#125;</span><br><span class="line">  Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>源码中可看到Launcher中初始化了<code>内部类ExtClassLoader</code>和<code>AppClassLoader</code>;</p></li><li><p>内部类ExtClassLoader和AppClassLoader的有相同的继承关系：<code>ExtClassLoader -- &gt; URLClassLoader --&gt; SecureClassLoader --&gt; ClassLoader</code>;</p></li><li><p>源码中并没有初始化Bootstrap ClassLoader，只是通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>加载路径，这个就是Bootstrap ClassLoader加载jar包的路径.</p></li><li><p><strong>2. 路径加载的区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//Bootstrap ClassLoader -- Launcher中的静态变量加载</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ExtClassLoader -- Launcher中的内部类加载</span></span><br><span class="line">String str = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//AppClassLoader -- Launcher中的内部类加载</span></span><br><span class="line">String str = System.getProperty(<span class="string">"java.class.path"</span>);</span><br></pre></td></tr></table></figure></li><li><p>从上面这三个不同的加载路径，可以得到如下的结果:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>). Bootstrap ClassLoader</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\resources.jar;</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\rt.jar;E:\java_jdk_1.8\Java\jre.8.0_92\lib\sunrsasign.jar;</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\jsse.jar;</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\jce.jar;</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\charsets.jar;</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\jfr.jar;</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\classes</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>). ExtClassLoader</span><br><span class="line">E:\java_jdk_1.8\Java\jre.8.0_92\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>). AppClassLoader </span><br><span class="line">当前应用的bin目录，下面存放着<span class="class"><span class="keyword">class</span>文件</span></span><br><span class="line">E:\woorkspace_jni\MClassLoader\bin;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3-ClassLoader加载类的原理"><a href="#3-ClassLoader加载类的原理" class="headerlink" title="3. ClassLoader加载类的原理"></a>3. ClassLoader加载类的原理</h2><p><strong>(1). 双亲委托模型说明</strong></p><blockquote><p>(1). ClassLoader是使用双亲委托模型来加载类的，每一个ClassLoader的实例都有一个父加载器的引用(并不是父类),虚拟机内置的类加载器(Bootstrap ClassLoader)没有父加载器，但是它可以作为其他ClassLoader实例的父加载器。</p><p>(2). 当某一个ClassLoader的实例需要加载某一个类时，会先去委托其父加载器加载这类，直到自顶层的Bootstrap ClassLoader，如果Bootstrap ClassLoader完成了加载就直接返回，否则就转交给ExtClassLoader去加载，还没有加载就继续转交给AppClassLoader去加载，任然没有加载就返回给发起者，让它指定到文件系统或者网络的URL中加载该类，最终没有找到就会抛出异常ClassNotFoundException。</p></blockquote><p><strong>(2). 委托流程图</strong></p><p><img src="https://i.imgur.com/Oev9fED.png" alt></p><p><strong>(3). 为何使用双亲委托模型</strong></p><blockquote><p>因为可以避免重复加载，当父类加载了某一个类，字类的ClassLoader没必要再去重新加载一次。从安全角度考虑，假如不使用双亲委托模型，那我们便可以使用自定义的String类来替代Java中的核心api，这样会存在很大的安全隐患，如果使用双亲加载模型，当父加载器加载了之后，子加载器就不会再去加载，这样就无法使用自定义的String类替代Java中的，除非重新定义JDK中ClassLoader的加载算法。</p></blockquote><hr><h2 id="4-自定义ClassLoader"><a href="#4-自定义ClassLoader" class="headerlink" title="4. 自定义ClassLoader"></a>4. 自定义ClassLoader</h2><p><strong>(1). 重要方法：loadClass及其一般实现步骤</strong></p><ul><li><p>执行<code>findLoadedClass(String)</code>去检测这个class是不是已经加载过;</p></li><li><p>执行父加载器的loadClass方法,如果父加载器为null，则jvm内置的加载器去替代，也就是Bootstrap ClassLoader。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。</p></li><li><p>如果向上委托父加载器没有加载成功，则通过<code>findClass(String)</code>查找。</p></li><li><p>如果class在上面的步骤中找到了，参数resolve又是true的话，那么loadClass()又会调用resolveClass(Class)这个方法来生成最终的Class对象。</p></li></ul><p><strong>(2). 源码中看如何自定义</strong></p><ul><li><p>图片解释(图片来源忘记了…)</p><p><img src="https://i.imgur.com/cqZwevc.png" alt></p></li><li><p>源码解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//源码一：jdk1.8/jre8 路径下的java.lang.ClassLoader中的源码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Don't want to see this.</span></span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码二：jdk1.7/jre7 路径下的java.lang.ClassLoader中的源码</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>由源码及注释可以看出，我们自定义ClassLoader时步骤如下：</strong></p><blockquote><p>1.继承java.lang.ClassLoader;<br>2.重写findClass方法.</p></blockquote></li><li><p><strong>为什么只需要重写findClass？</strong></p><blockquote><p>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。</p></blockquote></li><li><p><strong>注意点</strong></p><blockquote><p><strong>1. defineClass()方法</strong><br>这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。<br><strong>2. 一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader</strong>，比如自定义的ClassLoader，父加载器默认是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。</p></blockquote></li></ul><p><strong>(3). 开始自定义ClassLoader</strong></p><ul><li><p><strong>1. 编译生成.class文件</strong><br>创建MTestLoader.java类，编译生成MTestLoader.class文件，然后可以在项目路径下找到相关.class文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MTestLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a customize ClassLoader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>2. 将上面的.class文件拷贝到备用目录,例如 E:\MLoaderTest</strong></p></li><li><p><strong>3. 创建自定义ClassLoader文件</strong></p><p>假定创建的文件名是：<code>DiskClassLoader</code>,继承自ClassLoader，然后重写<code>findClass(String className)</code>方法 ，该方法中的参数className是在创建ClassLoader对象后，调用loadClass时传入的，例如：<code>loader.loadClass(&quot;om.wd.loader.MTestLoader&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// class文件加载的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loadPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要加载的class名，假设fileName不为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = fileName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fileName + <span class="string">".class"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fileName.substring(index) + <span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiskClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadPath = path;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(loadPath, fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">            ByteArrayOutputStream bOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bOutputStream.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">byte</span>[] data = bOutputStream.toByteArray();</span><br><span class="line">      </span><br><span class="line">            bOutputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">      </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>4. 调用并输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//之前拷贝到备用目录保存的路径</span></span><br><span class="line">        DiskClassLoader loader = <span class="keyword">new</span> DiskClassLoader(<span class="string">"E:\\MLoaderTest"</span>);</span><br><span class="line">        <span class="comment">//获取指定的class</span></span><br><span class="line">        Class c = loader.loadClass<span class="string">"om.wd.loader.MTestLoader"</span>);</span><br><span class="line">        Object object = c.newInstance();</span><br><span class="line">        <span class="comment">//指定的方法</span></span><br><span class="line">        Method m = c.getDeclaredMethod(<span class="string">"mLoad"</span>, <span class="keyword">null</span>);</span><br><span class="line">        m.invoke(object, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">this</span> is a customize ClassLoader</span><br></pre></td></tr></table></figure></li></ul><p><strong>从输出结果可以看到，我们打印出了定义在MTestLoader.mLoad中的语句，由此证明我们自定义的ClassLoader成功加载了MTestLoader.class文件，并执行了里面的mLoad方法。</strong></p><hr><h2 id="5-contextClassLoader"><a href="#5-contextClassLoader" class="headerlink" title="5.contextClassLoader"></a>5.contextClassLoader</h2><p><strong>1. 简单了解</strong><br>contextClassLoader不是实际存在的ClassLoader，它只是Thread中的一个成员变量，包含setContextClassLoader和getContextClassLoader方法，我们可以在使用classloader的时候，动态的通过Thread的setContextClassLoader方法设置contextClassLoaer，从而绕过了双亲加载模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds the class loader for this Thread, in case there is one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the context ClassLoader for the receiver.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl The context ClassLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getContextClassLoader()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the context ClassLoader for this Thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ClassLoader The context ClassLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getContextClassLoader()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>以上就是有关ClassLoader的资料整理</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> classloader </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识：volatile关键字</title>
      <link href="/2019/02/14/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/02/14/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 要了解volatile关键字，我们就先要知道Java内存模型中的基本概念。</strong></p><p><strong>(1). 原子性</strong><br>一个操作或者多个操作要么全部执行并且执行过程中不被打断，或者全部不执行。  比如 : a++就不具备原子性，因为他可以拆分为a = a +1,非原子操作会存在线程安全问题，所有我们会使用同步(synchronized)技术来使他成为一个原子操作。</p><a id="more"></a><p><strong>(2). 可见性</strong><br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。使用volatite修饰的变量具有可见性，他不允许线程内部缓存和重排序，但是volatite修饰的变量并不能保证其原子性。</p><p><strong>(3). 有序性</strong><br>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。其中volatile是因为其本身包含“禁止指令重排序”的语义，而synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p><hr><p><strong>2. volatile有禁止指令重排的含义，那什么是指令重排呢？</strong><br>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var0 = <span class="number">10</span>;  <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> var1 = <span class="number">20</span>;  <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">2</span>;  <span class="comment">//语句3</span></span><br><span class="line">b = a * a;  <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>这段代码有可能的执行顺序：<strong>语句2 —&gt; 语句1 —&gt; 语句3 —&gt; 语句4</strong>;但是不可能的执行顺序：<strong>语句2 —&gt; 语句1 —&gt; 语句4—&gt; 语句3</strong>,因为语句4的结果会依赖于语句3，处理器在处理指令重排时会考虑数据之间的依赖性,但这只是针对单线程而言。</p><p><strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性，只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p><hr><p><strong>3. happens-before原则（先行发生原则）</strong><br>虽然Java中volatile和synchronized可以保证有序性，但是并不是所有操作都是用他们实现的，Java中原本就存在先行发生原则。</p><p><strong>(1). 什么是先行发生原则？</strong><br>先行发生原则是判断是否存在数据竞争、线程是否安全的主要依据。<br>比如说：操作A先行发生于操作B，操作A产生的影响能被操作B察觉。</p><p><strong>(2). Java内存模型中的先行关系</strong></p><ul><li><p><strong>程序次序规则：</strong>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作.</p></li><li><p><strong>锁定规则:</strong>一个unLock操作先行发生于后面对同一个锁的lock操作.</p></li><li><p><strong>volatile变量规则：</strong>对一个变量的写操作先行发生于后面对这个变量的读操作.</p></li><li><p><strong>传递规则：</strong>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C.</p></li><li><p><strong>线程启动规则：</strong>Thread对象的start()方法先行发生于此线程的每个一个动作.</p></li><li><p><strong>线程中断规则：</strong>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生.</p></li><li><p><strong>线程终结规则：</strong>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行.</p></li><li><p><strong>对象终结规则：</strong>一个对象的初始化完成先行发生于他的finalize()方法的开始.</p></li></ul><hr><p><strong>4. 剖析volatile关键字</strong><br><strong>(1).含义</strong><br>如果一个共享变量(类的成员变量、静态变量)用volatile修饰，将具有以下两种含义：</p><ul><li>保证不同的线程对该变量操作的可见性，即一个线程修改了该变量的值，对另外一个线程来说总是立即可见的.</li><li>禁止进行指令重排序.</li></ul><p><strong>(2).使用条件</strong><br>虽然volatile变量具有synchronized的可见性，但并不具备原子性，要想volatile提供理想的线程安全需要满足下面两个条件：</p><ul><li><p><strong>对变量的写操作不依赖于当前值</strong></p><p>这个条件限制了volatile修饰的变量不能用作线程安全计数器，因为x++操作其实包含了读取–修改–写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必要的原子性(单线程除外)。</p></li><li><strong>该变量没有包含在具有其他变量的不变式中.</strong></li></ul><p><strong>(3).使用场景</strong></p><ul><li><p><strong>作为状态标识</strong></p><p>使用volatile修饰的变量作为一个布尔状态的标志，用于标识某一次事件的改变，但是有一个共性就是：通常只有一种状态的转换，比如由false变为true，但是如果是循环改变，则会需要依赖原子特性。</p></li><li><p><strong>单例模式中使用</strong></p><p>在缺乏同步的情况下，可能会存在某个对象引用的更新值(该新值有线程1创建)和、该对象的状态旧值同时存在，也就是不同的线程创建了两个同样的对象，这就是我们所说的<strong>双重检查锁定</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">              instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定期观察改变数值</strong></p><p>比如某个后台线程，每隔几秒钟就更新一下当前是时间(获取其他的东西),然后更新volatile修饰的变量，从而其他的线程随时可以看到该变量最新的值。</p></li><li><p><strong>开销较低的”读-写锁操作”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">  count ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于这种写操作是同步的，但是读操作不使用同步的，也能使多个线程同时得到count最新的值。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础知识点合集(1)</title>
      <link href="/2019/02/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%90%88%E9%9B%86(1)/"/>
      <url>/2019/02/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%90%88%E9%9B%86(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1">1. Properties</a></li><li><a href="#2">2. 设计模式-代理模式</a></li><li><a href="#3">3. 反射(Reflection)</a><ul><li><a href="#3.1">3.1 关键类：Class类</a></li><li><a href="#3.2">3.2 反射的使用</a></li></ul></li><li><a href="#4">4. 锁机制</a><ul><li><a href="#4.1">4.1 synchronized</a></li><li><a href="#4.2">4.2 ReentrantLock</a>    </li></ul></li></ul><a id="more"></a><h2 id="1">一.Properties</h2><p><strong>1.基础-使用方法</strong><br><strong>例1：假如assets文件夹下，存在一个名为：YourName.properties的文件，我们通过下面的方式读取文件中的参数.</strong></p><ul><li><p><strong>文件内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourKey1=1</span><br><span class="line">YourKey2=BDC</span><br><span class="line">YourKey3=true</span><br></pre></td></tr></table></figure></li><li><p><strong>读取方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  InputStream inputStream = <span class="keyword">this</span>.getAssets().open(<span class="string">"YourName.properties"</span>);</span><br><span class="line">  properties.load(inputStream);</span><br><span class="line">  Log.d(TAG, properties.get(<span class="string">"YourKey"</span>));</span><br><span class="line">   <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>key值获取方式</strong></p><p>因为Properties继承自Hashtable,所以最终的获取方式还是和Hashtable中通过键值对的方式获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">      HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">      <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">              e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">          K eKey = e.key;</span><br><span class="line">          <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">              <span class="keyword">return</span> e.value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="2">二.设计模式-代理模式</h2><p><strong>1.静态代理</strong><br><strong>自我理解：静态代理就是由基础类提供统一的接口，实现类实现接口并完成具体的逻辑，代理类实现接口但并不再去修改具体实现逻辑，只是利用拥有的实现类的对象，调用相应的接口.</strong></p><ul><li><p><strong>基础类：提供统一接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MBaseInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readProxyName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeProxyName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProxyName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProxyName</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现类：实现具体逻辑</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MBaseImpl</span> <span class="keyword">implements</span> <span class="title">MBaseInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readProxyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">"MBaseImpl"</span>, <span class="string">""</span>+<span class="keyword">this</span>.getClass().getSimpleName()+<span class="string">".readProxyName"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeProxyName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">"MBaseImpl"</span>, <span class="string">""</span>+<span class="keyword">this</span>.getClass().getSimpleName()+<span class="string">".writeProxyName : "</span>+name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProxyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">"MBaseImpl"</span>, <span class="string">""</span>+<span class="keyword">this</span>.getClass().getSimpleName()+<span class="string">".findProxyName"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProxyName</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">"MBaseImpl"</span>, <span class="string">""</span>+<span class="keyword">this</span>.getClass().getSimpleName()+<span class="string">".findProxyName : "</span>+o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态代理类：利用实现类的实例调用接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MBaseImplProxy</span> <span class="keyword">implements</span> <span class="title">MBaseInterface</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MBaseInterface mBase;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MBaseImplProxy</span><span class="params">(MBaseInterface mInterface)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mBase = mInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readProxyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mBase.readProxyName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeProxyName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      mBase.writeProxyName(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProxyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mBase.findProxyName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProxyName</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      mBase.findProxyName(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>2.动态代理</strong><br><strong>自我理解 : 动态代理只能代理接口，不支持抽象类的代理，并且代理类要实现InvocationHandler接口，并通过反射机制，在运行时动态的决定代理对象.</strong></p><ul><li><p><strong>动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.object = o;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(o.getClass().getClassLoader(), o</span><br><span class="line">              .getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      Object obj = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Log.d(<span class="string">"ProxyHandler"</span>, <span class="string">"method : "</span> + method.toString());</span><br><span class="line">          obj = method.invoke(object, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>接口分析: java.lang.reflect.InvocationHandler</strong></p></li></ul><ol><li>InvocationHandler接口中只有一个方法：invoke;</li><li>proxy：表示代理;</li><li>method：表示原对象中被调用的方法(即上面MBaseImpl中的方法);</li><li><p>args：表示方法参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>代理分析</strong></p></li><li><p>newProxyInstance为获取一个代理对象，上面的ProxyHandler$getProxyInstance方法最终返回的是一个代理对象;</p></li><li><p>loader：代理对象的类加载器，需要将其指定为和目标对象同一个加载器;</p></li><li><p>interfaces：代理对象的接口，即目标对象的所有接口;</p></li><li><p>h:上述方法被拦截时，需要执行哪一个InvocationHandler的invoke方法，根据传入的目标返回一个代理对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">         Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"h == null"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getProxyClass(loader, interfaces).getConstructor(</span><br><span class="line">                 <span class="keyword">new</span> Class&lt;?&gt;[] &#123; InvocationHandler.class &#125;).newInstance(</span><br><span class="line">                 <span class="keyword">new</span> Object[] &#123; h &#125;);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (InternalError) (<span class="keyword">new</span> InternalError(ex.toString())</span><br><span class="line">                 .initCause(ex));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (InternalError) (<span class="keyword">new</span> InternalError(ex.toString())</span><br><span class="line">                 .initCause(ex));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (InternalError) (<span class="keyword">new</span> InternalError(ex.toString())</span><br><span class="line">                 .initCause(ex));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">         Throwable target = ex.getTargetException();</span><br><span class="line">         <span class="keyword">throw</span> (InternalError) (<span class="keyword">new</span> InternalError(target.toString())</span><br><span class="line">                 .initCause(target));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//静态代理</span></span><br><span class="line"></span><br><span class="line">  MBaseInterface mInterface =  <span class="keyword">new</span> MBaseImplProxy(<span class="keyword">new</span> MBaseImpl());</span><br><span class="line"></span><br><span class="line">  mInterface.readProxyName();</span><br><span class="line"></span><br><span class="line">  mInterface.writeProxyName(<span class="string">"proxy"</span>);</span><br><span class="line"></span><br><span class="line">  mInterface.findProxyName();</span><br><span class="line"></span><br><span class="line">  mInterface.findProxyName(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理</span></span><br><span class="line">ProxyHandler pHandler = <span class="keyword">new</span> ProxyHandler();</span><br><span class="line">MBaseInterface mInterface2 = (MBaseInterface) pHandler.getProxyInstance(<span class="keyword">new</span> MBaseImpl());</span><br><span class="line">mInterface2.readProxyName();</span><br><span class="line">mInterface2.writeProxyName(<span class="string">"proxy"</span>);</span><br><span class="line">mInterface2.findProxyName();</span><br><span class="line">mInterface2.findProxyName(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>静态代理图示</strong><br><img src="http://i.imgur.com/a2P3vnQ.png" alt="静态代理图示"></p></li><li><p><strong>动态代理图示</strong><br><img src="http://i.imgur.com/XC851p0.png" alt="动态代理图示"></p></li></ul><hr><h2 id="3"> 三.反射(Reflection) </h2><p><strong>自我理解 ：反射主要是指程序可以访问、检测和修改自身的状态或者行为的一种能力，通过对应的全路径类名、函数名、变量名来获取并执行、改变一些不能直接调用的函数，达到程序期望的效果.</strong></p><h3 id="3.1"> 3.1 关键类：Class类 </h3><p><strong>Class类的获取方式有很多，一般在反射中我们使用的==Class.forName==的方式来获取Class对象,Class类中包含很多我们在反射中需要用的方法，这些方法获取到的函数有修饰域的限制，注意使用时的选择.</strong></p><p><strong>1. 构造方法的获取</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">根据构造函数的参数，返回一个具体的具有<span class="keyword">public</span>属性的构造函数</span><br><span class="line"><span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class[] params)</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">返回所有具有<span class="keyword">public</span>属性的构造函数数组</span></span><br><span class="line"><span class="function">Constructor <span class="title">getConstructors</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">　　　 　</span></span><br><span class="line"><span class="function">根据构造函数的参数，返回一个具体的构造函数（不分<span class="keyword">public</span>和非<span class="keyword">public</span>属性）</span></span><br><span class="line"><span class="function">Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class[] params)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">返回该类中所有的构造函数数组（不分<span class="keyword">public</span>和非<span class="keyword">public</span>属性）</span></span><br><span class="line"><span class="function">Constructor <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p><strong>2. 成员方法的获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">根据方法名和参数，返回一个具体的具有<span class="keyword">public</span>属性的方法</span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class[] params)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">返回所有具有<span class="keyword">public</span>属性的方法数组</span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">根据方法名和参数，返回一个具体的方法（不分<span class="keyword">public</span>和非<span class="keyword">public</span>属性）</span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class[] params)</span>   </span></span><br><span class="line"><span class="function">　　　　</span></span><br><span class="line"><span class="function">返回该类中的所有的方法数组（不分<span class="keyword">public</span>和非<span class="keyword">public</span>属性）</span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>3. 成员变量(属性)的获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">根据变量名，返回一个具体的具有<span class="keyword">public</span>属性的成员变量</span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">返回具有<span class="keyword">public</span>属性的成员变量的数组</span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">根据变量名，返回一个成员变量（不分<span class="keyword">public</span>和非<span class="keyword">public</span>属性）</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">返回所有成员变量组成的数组（不分<span class="keyword">public</span>和非<span class="keyword">public</span>属性）</span></span><br><span class="line"><span class="function">Field[] <span class="title">getDelcaredField</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>4. Object 对象和 invoke 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Oject对象的获取方式可分为以下两种:</span><br><span class="line">    <span class="number">1</span>. 通过Class对象获取</span><br><span class="line">         Object o1 = <span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>. 通过构造函数Constructor获取,其中是可变参数，根据构造函数的参数传递</span><br><span class="line">         Object o2 = cons.newInstance(Object... args);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object receiver, Object... args)</span>方法</span></span><br><span class="line"><span class="function">    receiver:作为接收对象，被底层方法调用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    args：可变参数，根据方法的参数传递</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">invoke</span><span class="params">(obj,new Object[]&#123;你要执行的方法所对应的参数&#125;)</span></span></span><br><span class="line"><span class="function">    <span class="title">invoke</span><span class="params">(obj,new Object[]&#123;<span class="string">"Sync"</span>,<span class="number">99</span>&#125;)</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="3.2"> 3.2 反射的使用 </h3><p><strong>1. 基础类1</strong><br><strong>MReflectionBase中提供private构造方法、private参数和public函数.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MReflectionBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MReflectionBase"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mCanReflec = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> String mReflecStr = <span class="string">"Java Reflection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MReflectionBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getmReflecStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"getmReflecStr is run  "</span> + mReflecStr);</span><br><span class="line">        <span class="keyword">return</span> mReflecStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmReflecStr</span><span class="params">(String mReflecStr)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"setmReflecStr is run  "</span> + mReflecStr);</span><br><span class="line">        <span class="keyword">this</span>.mReflecStr = mReflecStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">canReflec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mCanReflec)&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"mCanReflec  success : "</span> + mCanReflec);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"mCanReflec failuer :  "</span> + mCanReflec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 实现类1</strong><br><strong>注意MReflectionBase中包含私有的函数及变量.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c1 = Class.forName(<span class="string">"com.wd.javalib.reflec.MReflectionBase"</span>);</span><br><span class="line"></span><br><span class="line">            Constructor constructor = c1.getDeclaredConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//私有的构造函数，所以setAccessible(true)</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o1 = constructor.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            Method m1 = c1.getDeclaredMethod(<span class="string">"getmReflecStr"</span>);</span><br><span class="line">            m1.invoke(o1,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            Method m2  = c1.getDeclaredMethod(<span class="string">"setmReflecStr"</span>,String.class);</span><br><span class="line">            m2.invoke(o1,<span class="string">"change to mReflec success"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//before</span></span><br><span class="line">            Method m3 = c1.getMethod(<span class="string">"canReflec"</span>);</span><br><span class="line">            m3.invoke(o1,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//after</span></span><br><span class="line">            Field f1 = c1.getDeclaredField(<span class="string">"mCanReflec"</span>);</span><br><span class="line">            <span class="comment">//java.lang.IllegalAccessException: Cannot access field: boolean com.wd.javalib.reflec.MReflectionBase.mCanReflec</span></span><br><span class="line">            f1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            f1.set(o1,<span class="keyword">false</span>);</span><br><span class="line">            m3.invoke(o1,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong><br>从结果中可以看出，我们对方法的调用、变量的修改都起到了作用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/MReflectionBase: getmReflecStr is run  Java Reflection</span><br><span class="line">D/MReflectionBase: setmReflecStr is run  change to mReflec success</span><br><span class="line">D/MReflectionBase: mCanReflec  success : <span class="keyword">true</span></span><br><span class="line">D/MReflectionBase: mCanReflec failuer :  <span class="keyword">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>3. 基础类2</strong><br><strong>继承自MReflectionBase，剩下就是简单的实现.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MReflectionImpl</span> <span class="keyword">extends</span> <span class="title">MReflectionBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MReflectionImpl"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mReflecNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MReflectionImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl  contructor with empty "</span>);</span><br><span class="line">        mReflecNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MReflectionImpl</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl  contructor with int  var0 : "</span> + var0);</span><br><span class="line">        mReflecNum = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MReflectionImpl</span><span class="params">(<span class="keyword">int</span> var1, String var2)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl  contructor with int and string  var1 : "</span> + var1 + <span class="string">",  var2 : "</span> + var2);</span><br><span class="line">        mReflecNum = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReflecMess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl getReflecMess is run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReflecMess</span><span class="params">(String var3)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl getReflecMess is run  with var3 : "</span> + var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReflecMess</span><span class="params">(String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl getReflecMess is run  with var3 : "</span> + var3 + <span class="string">",   var4 : "</span> + var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmReflecNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl getmReflecNum is run "</span>);</span><br><span class="line">        <span class="keyword">return</span> mReflecNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setmReflecNum</span><span class="params">(<span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl private  setmReflecNum  is run   var4 : "</span> + var4 + <span class="string">", var5 "</span> + var5);</span><br><span class="line">        <span class="keyword">this</span>.mReflecNum = var4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmReflecNum</span><span class="params">(<span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"MReflectionImpl public  setmReflecNum  is run   var4 : "</span> + var4);</span><br><span class="line">        <span class="keyword">this</span>.mReflecNum = var4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 实现类2</strong><br><strong>run2列举了通过不同的方式获取构造函数、成员函数的具体实例，可以比较清晰的了解反射使用的方式.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class var0;</span><br><span class="line">            Object var1 = (var0 = Class.forName(<span class="string">"com.wd.javalib.reflec.MReflectionImpl"</span>)).newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不同参数的构造方法</span></span><br><span class="line">            Object var2 = var0.getDeclaredConstructor().newInstance();</span><br><span class="line">            Object var3 = var0.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class&#125;).newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">100</span>&#125;);</span><br><span class="line">            Object var4 = var0.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class,String.class&#125;).newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">200</span>,<span class="string">"this is newInstance"</span>&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不同参数的函数</span></span><br><span class="line">            Method var5 = var0.getDeclaredMethod(<span class="string">"getReflecMess"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            var5.invoke(var1,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">            Method var6 = var0.getDeclaredMethod(<span class="string">"getReflecMess"</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">            <span class="comment">//var6.invoke(var1,"you can input words");</span></span><br><span class="line">            var6.invoke(var1,<span class="keyword">new</span> Object[]&#123;<span class="string">"you can input here"</span>&#125;);</span><br><span class="line">            Method var7 = var0.getDeclaredMethod(<span class="string">"getReflecMess"</span>,<span class="keyword">new</span> Class[]&#123;String.class,<span class="keyword">int</span>.class&#125;);</span><br><span class="line">            var7.invoke(var1,<span class="keyword">new</span> Object[]&#123;<span class="string">"you can input num for int type"</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//私有</span></span><br><span class="line">            Method var8 = var0.getDeclaredMethod(<span class="string">"setmReflecNum"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class,<span class="keyword">int</span>.class&#125;);</span><br><span class="line">            var8.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            var8.invoke(var1,<span class="keyword">new</span> Object[]&#123;<span class="number">300</span>,<span class="number">400</span>&#125;);</span><br><span class="line">            <span class="comment">//共有</span></span><br><span class="line">            Method var9 = var0.getDeclaredMethod(<span class="string">"setmReflecNum"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class&#125;);</span><br><span class="line">            var9.invoke(var1,<span class="keyword">new</span> Object[]&#123;<span class="number">500</span>&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取该类中所有的方法(public &amp; private)</span></span><br><span class="line">            Method[] var10 = var0.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method m : var10)&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"-------Method Name : "</span> + m.getName() + <span class="string">",  mod : "</span>+ Modifier.toString(m.getModifiers()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取所有的public方法，不局限于该类</span></span><br><span class="line">            Method[] var11 = var0.getMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method m : var11)&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"Method Name : "</span> + m.getName() + <span class="string">",  mod : "</span>+ Modifier.toString(m.getModifiers()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4"> 四.锁机制 </h2><h4 id="4.1"> 4.1 synchronized(同步) </h4><p><strong>synchronized是Java中的关键字，是一种同步锁，当他用来修饰一个方法或者一个代码块时，能够保证同一时刻最多只有一个线程执行该段代码.synchronized修饰的对象大致可以分为以下几种：</strong></p><table><thead><tr><th>修饰范围</th><th>别称</th><th>作用范围</th><th>作用对象</th></tr></thead><tbody><tr><td>修饰代码块</td><td>同步语句块</td><td>大括号{}里面的代码</td><td>调用该段代码的对象</td></tr><tr><td>修饰方法</td><td>同步方法</td><td>整个方法</td><td>调用该方法的对象</td></tr><tr><td>修饰静态方法</td><td>***</td><td>整个静态方法</td><td>该静态方法所属类的所有对象</td></tr><tr><td>修饰类</td><td>***</td><td>整个类</td><td>该类的所有对象</td></tr></tbody></table><ul><li><p><strong>测试方法1：修饰代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MReentrantLockBase</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MReentrantLockBase"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lockCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"thread : "</span> + Thread.currentThread().getName() + <span class="string">", lockCount : "</span> + (lockCount++));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用</span></span><br><span class="line">MReentrantLockBase lockBase =  <span class="keyword">new</span> MReentrantLockBase();</span><br><span class="line">Thread var0  = <span class="keyword">new</span> Thread(lockBase,<span class="string">"lockThread1"</span>);</span><br><span class="line">Thread var1  = <span class="keyword">new</span> Thread(lockBase,<span class="string">"lockThread2"</span>);</span><br><span class="line">var0.start();</span><br><span class="line">var1.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>执行结果1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">09</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">25.339</span> D/MReentrantLockBase: thread : lockThread1, lockCount : <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">09</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">26.340</span> D/MReentrantLockBase: thread : lockThread1, lockCount : <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">09</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">27.341</span> D/MReentrantLockBase: thread : lockThread1, lockCount : <span class="number">2</span></span><br><span class="line"><span class="number">07</span>-<span class="number">09</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">28.343</span> D/MReentrantLockBase: thread : lockThread2, lockCount : <span class="number">3</span></span><br><span class="line"><span class="number">07</span>-<span class="number">09</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">29.344</span> D/MReentrantLockBase: thread : lockThread2, lockCount : <span class="number">4</span></span><br><span class="line"><span class="number">07</span>-<span class="number">09</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">30.346</span> D/MReentrantLockBase: thread : lockThread2, lockCount : <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>从执行结果来看，线程1调用代码块全部执行结束之后，线程2才开始执行，保持先后执行的顺序.</p></blockquote><hr><ul><li><p><strong>测试方法2：修饰整个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MReentrantLockBase</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MReentrantLockBase"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lockCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"thread : "</span> + Thread.currentThread().getName() + <span class="string">", lockCount : "</span> + (lockCount++));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用</span></span><br><span class="line">MReentrantLockBase lockBase =  <span class="keyword">new</span> MReentrantLockBase();</span><br><span class="line">Thread var0  = <span class="keyword">new</span> Thread(lockBase,<span class="string">"lockThread1"</span>);</span><br><span class="line">Thread var1  = <span class="keyword">new</span> Thread(lockBase,<span class="string">"lockThread2"</span>);</span><br><span class="line">var0.start();</span><br><span class="line">var1.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>执行结果2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">44</span>:<span class="number">56.043</span>  D/MReentrantLockBase: thread : lockThread1, lockCount : <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">44</span>:<span class="number">57.043</span>  D/MReentrantLockBase: thread : lockThread1, lockCount : <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">44</span>:<span class="number">58.043</span>  D/MReentrantLockBase: thread : lockThread1, lockCount : <span class="number">2</span></span><br><span class="line"><span class="number">07</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">44</span>:<span class="number">59.044</span>  D/MReentrantLockBase: thread : lockThread2, lockCount : <span class="number">3</span></span><br><span class="line"><span class="number">07</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">45</span>:<span class="number">00.045</span>  D/MReentrantLockBase: thread : lockThread2, lockCount : <span class="number">4</span></span><br><span class="line"><span class="number">07</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">45</span>:<span class="number">01.045</span>  D/MReentrantLockBase: thread : lockThread2, lockCount : <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>同样的执行代码，只是synchronized的位置不同，同步代码块和同步方法执行结果一致,锁住的是传入的对象.</p></blockquote><hr><ul><li><p><strong>测试方法3：修饰静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSyncHronized</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Log.d(<span class="string">"msync"</span>, <span class="string">"syncA is run : "</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用</span></span><br><span class="line"><span class="keyword">final</span> MSyncHronized mHronized = <span class="keyword">new</span> MSyncHronized();</span><br><span class="line"><span class="keyword">final</span> MSyncHronized mHronized1 = <span class="keyword">new</span> MSyncHronized();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHronized.syncA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHronized1.syncA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>执行结果3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">10</span>:<span class="number">30</span>:<span class="number">26.438</span> <span class="number">4027</span>-<span class="number">4068</span>/ D/msync: syncA is run : <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">10</span>:<span class="number">30</span>:<span class="number">27.438</span> <span class="number">4027</span>-<span class="number">4068</span>/ D/msync: syncA is run : <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">10</span>:<span class="number">30</span>:<span class="number">28.438</span> <span class="number">4027</span>-<span class="number">4068</span>/ D/msync: syncA is run : <span class="number">2</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">10</span>:<span class="number">30</span>:<span class="number">29.440</span> <span class="number">4027</span>-<span class="number">4069</span>/ D/msync: syncA is run : <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">10</span>:<span class="number">30</span>:<span class="number">30.440</span> <span class="number">4027</span>-<span class="number">4069</span>/ D/msync: syncA is run : <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">10</span>:<span class="number">30</span>:<span class="number">31.440</span> <span class="number">4027</span>-<span class="number">4069</span>/ D/msync: syncA is run : <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用static synchronized修饰方法，由于static的方法是属于类的，虽然mHronized、mHronized1是MSyncHronized的两个不同的对象，但是执行时t1、t2保持了线程同步，所以mHronized、mHronized1相当于持有的是同一把锁.</p></blockquote><hr><ul><li><p><strong>测试方法4：修饰类对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSyncClazz</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (MSyncClazz.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                Log.d(<span class="string">"msync"</span>, Thread.currentThread().getName()+<span class="string">"  MSyncClazz is run : "</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用</span></span><br><span class="line">MSyncClazz clazz = <span class="keyword">new</span> MSyncClazz();</span><br><span class="line">Thread var0 = <span class="keyword">new</span> Thread(clazz, <span class="string">"clazz1"</span>);</span><br><span class="line">Thread var1 = <span class="keyword">new</span> Thread(clazz, <span class="string">"clazz2"</span>);</span><br><span class="line"></span><br><span class="line">var0.start();</span><br><span class="line">var1.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>执行结果4</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">28.420</span> <span class="number">24057</span>-<span class="number">24091</span>/ D/msync: clazz1  MSyncClazz is run : <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">29.421</span> <span class="number">24057</span>-<span class="number">24091</span>/ D/msync: clazz1  MSyncClazz is run : <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">30.421</span> <span class="number">24057</span>-<span class="number">24091</span>/ D/msync: clazz1  MSyncClazz is run : <span class="number">2</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">31.422</span> <span class="number">24057</span>-<span class="number">24092</span>/ D/msync: clazz2  MSyncClazz is run : <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">32.422</span> <span class="number">24057</span>-<span class="number">24092</span>/ D/msync: clazz2  MSyncClazz is run : <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">11</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">33.422</span> <span class="number">24057</span>-<span class="number">24092</span>/ D/msync: clazz2  MSyncClazz is run : <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用synchronized修饰类用法是：synchronized (MSyncClazz.class){},并不是把synchronized放在类名上面，从打印日志可以看出，c1,c2同样是MSyncClazz的对象，然后var0、var1也保持了线程同步，这样也就相当于c1、c2也持有同一把锁，也就是synchronized作用于类，该类的所有对象都会同步</p></blockquote><p><strong>注意事项:</strong></p><ol><li>synchronized关键字不能继承如果服了的某个方法是synchronized修饰的，子类重写该方法并不是同步的，除非加上该关键字，或者显 &gt;     示的调用父类的方法，super.merhod();</li><li>定义接口是不能使用synchronized的关键字;</li><li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步.</li></ol><hr><h4 id="4.2"> 4.2 ReentrantLock(可重入锁) </h4><p><strong>1. 初步理解</strong></p><ol><li>ReentrantLock从源码来看，其实并没有做很多实际的东西，虽然实现了Lock接口，但是其内部有一个抽象的</li><li>Sync类，调用ReentrantLock的lock()方法，最终内部实现也是sync.lock()，值得关注的是Sync也是继承自</li><li>抽象类AbstractQueuedSynchronizer，再往上延伸至抽象类AbstractOwnableSynchronizer。</li></ol><p><strong>2. 关注点</strong></p><ol><li>接口调用 ： lock() 与 unLock() 一定要成对调用，否则容易造成死锁;</li><li><p>Condition条件的获取 ： Condition c=lock.newCondition()，</p><p>最终返回的AbstractQueuedSynchronizer$ConditionObject对象，Condition只是一个接口;</p></li><li>Condition接口signal()信号 和 await() 等待的配合使用;</li></ol><p><strong>3.1 源码浅析 : RentrantLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类-非公平的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类-公平的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.2 源码浅析 : Condition</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 利弊的选择</strong></p><ul><li><p><strong>synchronized获得内部锁的局限性</strong></p></li><li><p>不能中断一个正在试图获得锁的线程;</p></li><li><p>试图获得锁的时不能像tryLock一样设置超时时间;</p></li><li><p>每个锁只有单一的条件，不能像condition一样设置多个.</p></li><li><p><strong>synchronized与reentrantLock的选择(简单建议)</strong></p></li><li><p>如果synchronized关键字适合程序，可以优先选择，这样会减少错误率和代码量;</p></li><li><p>如果特定的情形需要使用Lock&amp;Condition结合的情况则使用.</p></li></ul><p><strong>5. ReentrantLock简单实例</strong></p><ul><li><p><strong>描述</strong></p><blockquote><p>两个线程，A先输出1-3，然后通知B输出4-6，然后通知A再输出7-9，最后结束.</p></blockquote></li><li><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MReentrantLockBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MReentrantLockBase"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现从1-9日志输出， 线程1从1-3输出， 然后通知线程2从4-6输出， 然后再通知线程1从7-9输出.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      <span class="comment">// 条件1：输出1-3之后发出通知</span></span><br><span class="line">      <span class="keyword">final</span> Condition c1 = lock.newCondition();</span><br><span class="line">      <span class="comment">// 条件2：输出4-6之后发出通知</span></span><br><span class="line">      <span class="keyword">final</span> Condition c2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Log.d(TAG, <span class="string">"第一次    t1 进入准备输出-------"</span>);</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  <span class="keyword">while</span> (out &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                      out++;</span><br><span class="line">                      Log.d(TAG, <span class="string">"t1   输出数字   "</span> + out);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 通知t2可以执行</span></span><br><span class="line">                  c1.signal();</span><br><span class="line">                  Log.d(TAG, <span class="string">"t1   c1.signal()"</span>);</span><br><span class="line">                  <span class="comment">// 等待t2执行结束的消息</span></span><br><span class="line">                  c2.await();</span><br><span class="line">                  Log.d(TAG, <span class="string">"t1   c2.await()"</span>);</span><br><span class="line">                  Log.d(TAG, <span class="string">"第二次   t1 准备输出-------"</span>);</span><br><span class="line">                  <span class="keyword">while</span> (out &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                      out++;</span><br><span class="line">                      Log.d(TAG, <span class="string">"t1   输出数字   "</span> + out);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  Log.d(TAG, <span class="string">"t1输出结束-------"</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Log.d(TAG, <span class="string">"第一次    t2 进入准备输出-------"</span>);</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  <span class="keyword">if</span> (out &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                      <span class="comment">//等待t1结束的消息</span></span><br><span class="line">                      Log.d(TAG, <span class="string">"t2   c1.await()"</span>);</span><br><span class="line">                      c1.await();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  Log.d(TAG, <span class="string">"第一次    t2 等待结束-------"</span>);</span><br><span class="line">                  <span class="keyword">while</span> (out &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                      out++;</span><br><span class="line">                      Log.d(TAG, <span class="string">"t2   输出数字   "</span> + out);</span><br><span class="line">                  &#125;</span><br><span class="line">                  c2.signal();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.694</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: 第一次    t1 进入准备输出-------</span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.694</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   输出数字   <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.694</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   输出数字   <span class="number">2</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.694</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   输出数字   <span class="number">3</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.694</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   c1.signal()</span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22583</span>/? D/MReentrantLockBase: 第一次    t2 进入准备输出-------</span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22583</span>/? D/MReentrantLockBase: 第一次    t2 等待结束-------</span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22583</span>/? D/MReentrantLockBase: t2   输出数字   <span class="number">4</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22583</span>/? D/MReentrantLockBase: t2   输出数字   <span class="number">5</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22583</span>/? D/MReentrantLockBase: t2   输出数字   <span class="number">6</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   c2.await()</span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: 第二次   t1 准备输出-------</span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.695</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   输出数字   <span class="number">7</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.696</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   输出数字   <span class="number">8</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.696</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1   输出数字   <span class="number">9</span></span><br><span class="line"><span class="number">07</span>-<span class="number">12</span> <span class="number">13</span>:<span class="number">22</span>:<span class="number">18.696</span> <span class="number">22567</span>-<span class="number">22582</span>/? D/MReentrantLockBase: t1输出结束-------</span><br></pre></td></tr></table></figure></li><li><p><strong>结果分析:</strong></p></li><li><p>两个线程t1、t2，当t1输出结束后，通过前面获取的condition.signal()来发送信号，告诉t2”我执行完了，该轮到你了”，这时候t2不再等待，开始进行输出，完成后像前面一样发送signal来通知t1”又到你输出了—“;</p></li></ul><ol start="2"><li><p>在线程t2中有个条件判断使得t2一直是在等待状态，等待信号的到来，收到信号后便可执行任务，两个线程的信号发送和接收情况简单如下：</p><p>(1) t1线程中 : t1执行任务结束后，c1.signal()发送信号告诉t2中的的c1.await()，你可以不用等待了，开始执行任务吧，然后t1中的c2.await()等待线程t2发送信号过来，t1第一阶段结束;</p><p>(2) t2线程中 : t2中的c1.await()收到了信号，开始执行任务，执行完成后c2.signal()发送消息给t1</p><p>线程，你也不用等待了，可以执行任务了,t2结束;</p><p>(3) t1中的c2.await()收到了来自t2的消息，再次执行任务,完成后t1第二阶段结束.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 合集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>又见花开</title>
      <link href="/2018/12/14/%E5%8F%88%E8%A7%81%E8%8A%B1%E5%BC%80/"/>
      <url>/2018/12/14/%E5%8F%88%E8%A7%81%E8%8A%B1%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p>又见花开</p><p>枯黄的落叶</p><p>消失不见</p><p>嫩芽即将萌发</p>]]></content>
      
      
      <categories>
          
          <category> 杂言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 落 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sorry</title>
      <link href="/2018/12/12/Sorry/"/>
      <url>/2018/12/12/Sorry/</url>
      
        <content type="html"><![CDATA[<p>Say sorry,<br>if you.</p>]]></content>
      
      
      <categories>
          
          <category> 杂言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 失去 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maybes</title>
      <link href="/2018/12/12/Maybes/"/>
      <url>/2018/12/12/Maybes/</url>
      
        <content type="html"><![CDATA[<p>也许遇见你<br>我的世界就会不一样</p><p>也许不遇见你<br>我的世界就会不一样</p>]]></content>
      
      
      <categories>
          
          <category> 杂言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期待 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在我离开的日子里</title>
      <link href="/2018/12/07/%E5%9C%A8%E6%88%91%E7%A6%BB%E5%BC%80%E7%9A%84%E6%97%A5%E5%AD%90%E9%87%8C/"/>
      <url>/2018/12/07/%E5%9C%A8%E6%88%91%E7%A6%BB%E5%BC%80%E7%9A%84%E6%97%A5%E5%AD%90%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<p>纷扰的岁月</p><p>映照这整夜的失眠</p><p>陌生的世界啊</p>]]></content>
      
      
      <categories>
          
          <category> 杂言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 念 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
