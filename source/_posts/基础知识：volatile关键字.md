---
title: 基础知识：volatile关键字
copyright: true
date: 2019-02-14 21:01:12
tags:
- Java
categories:
- Java
---

**1. 要了解volatile关键字，我们就先要知道Java内存模型中的基本概念。**

**(1). 原子性**
一个操作或者多个操作要么全部执行并且执行过程中不被打断，或者全部不执行。  比如 : a++就不具备原子性，因为他可以拆分为a = a +1,非原子操作会存在线程安全问题，所有我们会使用同步(synchronized)技术来使他成为一个原子操作。

<!-- more -->

**(2). 可见性**
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。使用volatite修饰的变量具有可见性，他不允许线程内部缓存和重排序，但是volatite修饰的变量并不能保证其原子性。

**(3). 有序性**
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。其中volatile是因为其本身包含“禁止指令重排序”的语义，而synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

---
**2. volatile有禁止指令重排的含义，那什么是指令重排呢？**
一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
**例如：**
```java
int var0 = 10;  //语句1
int var1 = 20;  //语句2
a = a + 2;  //语句3
b = a * a;  //语句4
```
这段代码有可能的执行顺序：**语句2 —> 语句1 —> 语句3 —> 语句4**;但是不可能的执行顺序：**语句2 —> 语句1 —> 语句4—> 语句3**,因为语句4的结果会依赖于语句3，处理器在处理指令重排时会考虑数据之间的依赖性,但这只是针对单线程而言。


**指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性，只要有一个没有被保证，就有可能会导致程序运行不正确。**


---
**3. happens-before原则（先行发生原则）**
虽然Java中volatile和synchronized可以保证有序性，但是并不是所有操作都是用他们实现的，Java中原本就存在先行发生原则。

**(1). 什么是先行发生原则？**
先行发生原则是判断是否存在数据竞争、线程是否安全的主要依据。
比如说：操作A先行发生于操作B，操作A产生的影响能被操作B察觉。

**(2). Java内存模型中的先行关系**
- **程序次序规则：**一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作.
 
- **锁定规则:**一个unLock操作先行发生于后面对同一个锁的lock操作.

- **volatile变量规则：**对一个变量的写操作先行发生于后面对这个变量的读操作.

- **传递规则：**如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C.

- **线程启动规则：**Thread对象的start()方法先行发生于此线程的每个一个动作.

- **线程中断规则：**对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生.

- **线程终结规则：**线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行.

- **对象终结规则：**一个对象的初始化完成先行发生于他的finalize()方法的开始.

---
**4. 剖析volatile关键字**
**(1).含义**
如果一个共享变量(类的成员变量、静态变量)用volatile修饰，将具有以下两种含义：
- 保证不同的线程对该变量操作的可见性，即一个线程修改了该变量的值，对另外一个线程来说总是立即可见的.
- 禁止进行指令重排序.

**(2).使用条件**
虽然volatile变量具有synchronized的可见性，但并不具备原子性，要想volatile提供理想的线程安全需要满足下面两个条件：
- **对变量的写操作不依赖于当前值**
这个条件限制了volatile修饰的变量不能用作线程安全计数器，因为x++操作其实包含了读取--修改--写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必要的原子性(单线程除外)。
- **该变量没有包含在具有其他变量的不变式中.**

**(3).使用场景**
- **作为状态标识**
使用volatile修饰的变量作为一个布尔状态的标志，用于标识某一次事件的改变，但是有一个共性就是：通常只有一种状态的转换，比如由false变为true，但是如果是循环改变，则会需要依赖原子特性。

- **单例模式中使用**
在缺乏同步的情况下，可能会存在某个对象引用的更新值(该新值有线程1创建)和、该对象的状态旧值同时存在，也就是不同的线程创建了两个同样的对象，这就是我们所说的**双重检查锁定**。
```java
private volatile static Singleton instance;
public static Singleton getInstance(){
	if(instance == null){
		synchronized(Singleton.class){
			if(instance == null){
				instance = new Singleton();
			}
		}
	}
	return instance;
}
```
     
- **定期观察改变数值**
比如某个后台线程，每隔几秒钟就更新一下当前是时间(获取其他的东西),然后更新volatile修饰的变量，从而其他的线程随时可以看到该变量最新的值。
 
- **开销较低的"读-写锁操作"**
```java
private volatile int count = 0;
public int getCount(){
    return count;
}
public synchronized void setCount(){
    count ++;
}
```
类似于这种写操作是同步的，但是读操作不使用同步的，也能使多个线程同时得到count最新的值。


 




